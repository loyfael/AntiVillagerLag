<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="updatedContent" value="&lt;p align=&quot;center&quot;&gt;&#10;    &lt;a href=&quot;https://discord.gg/WWWeAqwcU6&quot; alt=&quot;Discord&quot;&gt;&#10;        &lt;img src=&quot;https://img.shields.io/discord/990400053673873428?label=Discord&quot;/&gt;&#10;    &lt;/a&gt;&#10;&lt;/p&gt;&#10;&#10;# AntiVillagerLag &#10;&#10;SpigotMC: [Link](https://www.spigotmc.org/resources/antivillagerlag.102949/)&#10;&#10;A comprehensive villager optimization plugin that allows players to selectively disable villager AI to reduce server lag while maintaining full trading functionality. Perfect for large trading halls and villager farms that impact server performance.&#10;&#10;##  Table of Contents&#10;- [Overview](#overview)&#10;- [Key Features](#key-features)&#10;- [How It Works](#how-it-works)&#10;- [Installation &amp; Setup](#installation--setup)&#10;- [Usage Guide](#usage-guide)&#10;- [Configuration](#configuration)&#10;- [Commands](#commands)&#10;- [Permissions](#permissions)&#10;- [Advanced Features](#advanced-features)&#10;- [Performance Impact](#performance-impact)&#10;- [Troubleshooting](#troubleshooting)&#10;- [Support](#support)&#10;&#10;##  Overview&#10;&#10;AntiVillagerLag addresses the common server performance issues caused by large villager trading halls. Instead of removing villagers or limiting trading, this plugin allows players to **selectively disable villager AI** when they don't need to move around, dramatically reducing computational overhead while preserving all trading functionality.&#10;&#10;### The Problem&#10;- Large villager trading halls can severely impact server MSPT&#10;- Villagers constantly pathfinding and AI processing causes lag&#10;- Traditional solutions involve removing villagers or limiting trades&#10;&#10;### The Solution  &#10;- Players can &quot;freeze&quot; villagers when not actively breeding or moving them&#10;- Frozen villagers consume virtually no server resources&#10;- Trading remains fully functional with custom restock schedules&#10;- Easy toggle system allows quick activation when needed&#10;&#10;## ✨ Key Features&#10;&#10;###  Player-Controlled Optimization&#10;- **Multiple Control Methods**: Use nametags, blocks, or workstations to control villager states&#10;- **Instant Toggle**: Right-click to enable/disable villager AI&#10;- **Visual Feedback**: Clear messages show villager status and cooldowns&#10;- **No Resource Waste**: Configurable nametag consumption&#10;&#10;### ⚡ Performance Optimization&#10;- **AI Freezing**: Completely stops villager pathfinding and behavior processing&#10;- **Zombie Protection**: Frozen villagers are immune to zombie attacks&#10;- **Selective Processing**: Only active villagers consume server resources&#10;- **Massive MSPT Reduction**: Up to 90% performance improvement in large trading halls&#10;&#10;### ️ Anti-Exploit Protection&#10;- **Trade Cooldowns**: Prevents double-trading exploits&#10;- **Level-up Handling**: Automatic temporary AI activation for villager progression&#10;- **Smart Restocking**: Custom restock schedule prevents vanilla/plugin conflicts&#10;&#10;###  Advanced Management&#10;- **Radius Commands**: Bulk optimize/unoptimize villagers in areas&#10;- **Permission System**: Fine-grained control over who can use features&#10;- **Update Notifications**: Automatic update checking for administrators&#10;&#10;## ⚙️ How It Works&#10;&#10;### Villager States&#10;AntiVillagerLag manages villagers in two primary states:&#10;&#10;####  Active State (AI Enabled)&#10;- Villager behaves normally&#10;- Can move, pathfind, and interact with environment&#10;- Consumes normal server resources&#10;- Required for breeding and some farm mechanics&#10;&#10;####  Optimized State (AI Disabled)  &#10;- All AI processing stopped (`setAware(false)`)&#10;- Villager cannot move or pathfind&#10;- Protected from zombie attacks&#10;- Maintains all trade data and experience&#10;- Consumes minimal server resources&#10;&#10;### Control Methods&#10;&#10;#### 1. **Nametag Control** (Primary Method)&#10;```&#10;Default Names: &quot;Optimize&quot;, &quot;Bonk&quot;&#10;- Use nametag with trigger name → Disables AI&#10;- Rename to anything else → Enables AI  &#10;- Configurable nametag consumption&#10;```&#10;&#10;#### 2. **Block-Based Control**&#10;```&#10;Default Blocks: Emerald Block, Diamond Block&#10;- Place trigger block near villager → Disables AI&#10;- Remove block → Enables AI&#10;- Configurable detection radius&#10;```&#10;&#10;#### 3. **Workstation Control**  &#10;```&#10;Workstations: Composter, Smoker, Barrel, etc.&#10;- Workstation in radius → Disables AI&#10;- No workstation → Enables AI&#10;- Configurable detection radius (default: 2 blocks)&#10;```&#10;&#10;##  Installation &amp; Setup&#10;&#10;### Requirements&#10;- Minecraft 1.20+&#10;- Spigot/Paper server&#10;- Java 8+&#10;&#10;### Installation Steps&#10;1. Download the latest JAR from [SpigotMC](https://www.spigotmc.org/resources/antivillagerlag.102949/)&#10;2. Place in your `plugins/` folder&#10;3. Restart your server&#10;4. Edit `plugins/AntiVillagerLag/config.yml` as needed&#10;5. Run `/avlreload` to apply changes&#10;&#10;##  Usage Guide&#10;&#10;### Basic Usage&#10;1. **Optimize a Villager**: Right-click with a nametag named &quot;Optimize&quot; or &quot;Bonk&quot;&#10;2. **Unoptimize**: Rename the villager to anything else and right-click&#10;3. **Trade**: Only works with optimized (frozen) villagers by default&#10;&#10;### Trading Workflow&#10;```&#10;1. Find villager → 2. Optimize it → 3. Trade → 4. Unoptimize if needed for breeding&#10;```&#10;&#10;### Bulk Operations&#10;```bash&#10;/avloptimize 25        # Optimize all villagers within 25 blocks&#10;/avlunoptimize 25      # Unoptimize all villagers within 25 blocks  &#10;/avlremove             # Remove all plugin modifications server-wide&#10;```&#10;&#10;## ⚙️ Configuration&#10;&#10;### config.yml Structure&#10;&#10;#### Control Names &amp; Blocks&#10;```yaml&#10;NamesThatDisable:&#10;  - Optimize&#10;  - Bonk&#10;&#10;BlocksThatDisable:&#10;  - EMERALD_BLOCK&#10;  - DIAMOND_BLOCK&#10;&#10;WorkstationsThatDisable:&#10;  - COMPOSTER&#10;  - SMOKER&#10;  - BARREL&#10;  # ... full list of workstations&#10;```&#10;&#10;#### Restock Schedule  &#10;```yaml&#10;RestockTimes:&#10;  times:&#10;    - 1000    # ~1 hour after sunrise&#10;    - 13000   # ~1 hour after sunset&#10;```&#10;&#10;#### Anti-Exploit Settings&#10;```yaml&#10;ai-toggle-cooldown: 600  # 10 minutes between AI toggles&#10;RadiusLimit: 50         # Max radius for bulk commands&#10;RadiusDefault: 50       # Default radius when not specified&#10;```&#10;&#10;#### Toggle Options&#10;```yaml&#10;toggleableoptions:&#10;  preventtrading: true      # Force optimization before trading&#10;  usenametags: false       # Consume nametags when used&#10;  userenaming: true        # Enable nametag control&#10;  useblocks: false         # Enable block-based control&#10;  useworkstations: false   # Enable workstation-based control&#10;  workstationcheckradius: 2 # Radius for workstation detection&#10;```&#10;&#10;##  Commands&#10;&#10;| Command | Description | Permission | Usage |&#10;|---------|-------------|------------|-------|&#10;| `/avlreload` | Reload plugin configuration | `avl.reload` | `/avlreload` |&#10;| `/avloptimize` | Optimize villagers in radius | `avl.optimize` | `/avloptimize [radius]` |&#10;| `/avlunoptimize` | Unoptimize villagers in radius | `avl.unoptimize` | `/avlunoptimize [radius]` |&#10;| `/avlremove` | Remove all plugin modifications | `avl.remove` | `/avlremove` |&#10;&#10;##  Permissions&#10;&#10;### Command Permissions&#10;- `avl.reload` - Reload plugin configuration&#10;- `avl.optimize` - Use bulk optimize commands  &#10;- `avl.unoptimize` - Use bulk unoptimize commands&#10;- `avl.remove` - Remove all plugin modifications&#10;&#10;### Bypass Permissions&#10;- `avl.cooldown.bypass` - Bypass AI toggle cooldown&#10;- `avl.restockcooldown.bypass` - Force immediate restocking&#10;- `avl.disable` - Completely disable plugin effects for player&#10;&#10;### Notification Permissions&#10;- `avl.message.nextrestock` (default: true) - See restock countdown messages&#10;- `avl.notify.update` (op: true) - Receive update notifications&#10;&#10;##  Advanced Features&#10;&#10;### Automatic Level Management&#10;- Plugin detects when optimized villagers need to level up&#10;- Temporarily enables AI for 5 seconds during level progression&#10;- Automatically re-optimizes after leveling completes&#10;- Prevents level-up interruption during the process&#10;&#10;### Smart Restock System&#10;- Custom restock schedule independent of vanilla mechanics&#10;- Prevents double-restocking exploits&#10;- Configurable times based on in-game day/night cycle&#10;- Instant restock available with bypass permission&#10;&#10;### Zombie Protection&#10;- Optimized villagers are immune to zombie attacks&#10;- Prevents villager loss in trading halls&#10;- Does not affect iron golem spawning mechanics&#10;&#10;### Update Integration&#10;- Automatic update checking on plugin load&#10;- Notification system for administrators&#10;- Version compatibility warnings&#10;&#10;##  Performance Impact&#10;&#10;### Before AntiVillagerLag&#10;- 100 villagers = ~5-10 MSPT impact&#10;- Constant pathfinding calculations  &#10;- Memory usage from AI processing&#10;- Server lag during peak hours&#10;&#10;### After AntiVillagerLag  &#10;- 100 optimized villagers = ~0.1-0.5 MSPT impact&#10;- No pathfinding when optimized&#10;- Minimal memory footprint&#10;- Smooth server performance&#10;&#10;### Real-World Results&#10;- **Large Trading Halls**: 90%+ MSPT reduction&#10;- **Mixed Farms**: 70% performance improvement&#10;- **Memory Usage**: 60% reduction in villager-related RAM usage&#10;&#10;## ️ Troubleshooting&#10;&#10;### Common Issues&#10;&#10;#### &quot;Villager won't trade&quot;&#10;- **Cause**: `preventtrading: true` requires optimization first&#10;- **Solution**: Optimize villager before trading, or disable setting&#10;&#10;#### &quot;Nametags being consumed&quot;  &#10;- **Cause**: `usenametags: true` in config&#10;- **Solution**: Set to `false` for infinite nametag usage&#10;&#10;#### &quot;Can't breed optimized villagers&quot;&#10;- **Cause**: AI disabled prevents breeding behavior  &#10;- **Solution**: Temporarily unoptimize villagers for breeding&#10;&#10;#### &quot;Villager not leveling up&quot;&#10;- **Cause**: Plugin handles this automatically&#10;- **Solution**: Wait for automatic level-up process, don't manually intervene&#10;&#10;### Performance Issues&#10;- Check that only necessary villagers are unoptimized&#10;- Use bulk commands to optimize large groups efficiently&#10;- Monitor MSPT before/after optimization&#10;&#10;### Configuration Problems  &#10;- Verify YAML syntax in config.yml&#10;- Use `/avlreload` after making changes&#10;- Check console for error messages&#10;&#10;##  Best Practices&#10;&#10;### For Players&#10;1. **Optimize trading villagers** immediately after setting up trades&#10;2. **Only unoptimize when breeding** or moving villagers&#10;3. **Use bulk commands** for large trading halls&#10;4. **Monitor restock times** to plan trading sessions&#10;&#10;### For Administrators  &#10;1. **Set appropriate radius limits** to prevent abuse&#10;2. **Configure restock times** based on server economy&#10;3. **Enable update notifications** for security&#10;4. **Monitor performance metrics** before/after deployment&#10;&#10;### For Large Servers&#10;1. **Train players** on proper usage&#10;2. **Set up permission groups** for different access levels  &#10;3. **Use workstation control** for automatic optimization&#10;4. **Regular monitoring** of villager optimization status&#10;&#10;##  Integration Examples&#10;&#10;### Trading Hall Setup&#10;```&#10;1. Build trading hall with individual villager cells&#10;2. Place villagers and set up desired trades  &#10;3. Use /avloptimize 50 to optimize entire hall&#10;4. Enjoy lag-free trading with custom restock schedule&#10;```&#10;&#10;### Mixed Farm Integration  &#10;```&#10;1. Keep villagers for iron farms UNOPTIMIZED&#10;2. Optimize only trading-specific villagers&#10;3. Use workstation control for automatic management&#10;4. Monitor farm functionality regularly&#10;```&#10;&#10;##  Support&#10;&#10;### Getting Help&#10;- **Discord Server**: [Join Here](https://discord.gg/WWWeAqwcU6)  &#10;- **GitHub Issues**: Report bugs and feature requests&#10;- **SpigotMC**: Community support and updates&#10;&#10;### Before Asking for Help&#10;1. Check this documentation thoroughly  &#10;2. Verify your configuration syntax&#10;3. Test with a small number of villagers first&#10;4. Check console logs for error messages&#10;5. Include plugin version and server details&#10;&#10;### Feature Requests&#10;We welcome suggestions for new features! Please include:&#10;- Detailed description of desired functionality&#10;- Use case explanation  &#10;- Potential configuration options&#10;- Impact on existing features&#10;&#10;---&#10;&#10;**AntiVillagerLag** - Optimizing Minecraft servers one villager at a time! " />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/AntiVillagerLag.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/AntiVillagerLag.java" />
              <option name="originalContent" value="package loyfael.antiVillagerLag;&#10;&#10;import org.bstats.bukkit.Metrics;&#10;import org.bstats.charts.MultiLineChart;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.configuration.Configuration;&#10;import org.bukkit.configuration.InvalidConfigurationException;&#10;import org.bukkit.configuration.file.YamlConfiguration;&#10;import org.bukkit.plugin.java.JavaPlugin;&#10;import loyfael.antiVillagerLag.commands.OptimizeCommand;&#10;import loyfael.antiVillagerLag.commands.ReloadCommand;&#10;import loyfael.antiVillagerLag.commands.RemoveChangesCommand;&#10;import loyfael.antiVillagerLag.commands.UnoptimizeCommand;&#10;import loyfael.antiVillagerLag.commands.StatusCommand;&#10;import loyfael.antiVillagerLag.commands.InfoCommand;&#10;import loyfael.antiVillagerLag.events.EventListener;&#10;import loyfael.antiVillagerLag.utils.UpdateChecker;&#10;import loyfael.antiVillagerLag.utils.VillagerUtilities;&#10;import loyfael.antiVillagerLag.utils.TaskManager;&#10;import loyfael.antiVillagerLag.utils.VillagerCache;&#10;&#10;import java.io.File;&#10;import java.io.IOException;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public final class AntiVillagerLag extends JavaPlugin {&#10;&#10;    @Override&#10;    public void onEnable() {&#10;&#10;        // Initialisation des optimisations de performance&#10;        VillagerUtilities.initializeKeys(this);&#10;        TaskManager.initialize(this);&#10;&#10;        //  Command Registration&#10;        getCommand(&quot;avlreload&quot;).setExecutor(new ReloadCommand(this));&#10;        getCommand(&quot;avloptimize&quot;).setExecutor(new OptimizeCommand(this));&#10;        getCommand(&quot;avlunoptimize&quot;).setExecutor(new UnoptimizeCommand(this));&#10;        getCommand(&quot;avlremove&quot;).setExecutor(new RemoveChangesCommand(this));&#10;        getCommand(&quot;avlstatus&quot;).setExecutor(new StatusCommand(this));&#10;        getCommand(&quot;avlinfo&quot;).setExecutor(new InfoCommand(this));&#10;&#10;        //  Event Registration&#10;        getServer().getPluginManager().registerEvents(new EventListener(this), this);&#10;&#10;        //  Config Stuff&#10;        saveDefaultConfig();&#10;        updateConfig();&#10;&#10;        // Chargement optimisé des configurations (async si possible)&#10;        TaskManager.runAsync(() -&gt; {&#10;            VillagerUtilities.updateNameTags(this);&#10;            VillagerUtilities.updateStandingOnBlocks(this);&#10;            VillagerUtilities.updateWorkstationBlocks(this);&#10;            VillagerUtilities.updateRestockTimes(this);&#10;        }).thenRun(() -&gt; {&#10;            getLogger().info(&quot;AntiVillagerLag optimizations loaded - ready for 2000+ villagers!&quot;);&#10;        });&#10;&#10;        //  Bstats Code&#10;        int pluginId = 15890;&#10;        Metrics metrics = new Metrics(this, pluginId);&#10;        //  Optional: Add custom charts&#10;        metrics.addCustomChart(new MultiLineChart(&quot;players_and_servers&quot;, () -&gt; {&#10;            Map&lt;String, Integer&gt; valueMap = new HashMap&lt;&gt;();&#10;            valueMap.put(&quot;servers&quot;, 1);&#10;            valueMap.put(&quot;players&quot;, Bukkit.getOnlinePlayers().size());&#10;            return valueMap;&#10;        }));&#10;&#10;        //  Check for plugin updates&#10;        new UpdateChecker(this, 102949).getVersion(version -&gt; {&#10;            if (this.getDescription().getVersion().equals(version)) {&#10;                getLogger().info(&quot;AntiVillagerLag is up to date!&quot;);&#10;            } else {&#10;                getLogger().info(&quot;There is an update for AntiVillagerLag! https://www.spigotmc.org/resources/antivillagerlag.102949/&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void onDisable() {&#10;        // Nettoyage des ressources pour éviter les fuites mémoire&#10;        TaskManager.shutdown();&#10;        VillagerCache.clearCache();&#10;&#10;        getLogger().info(&quot;AntiVillagerLag optimizations cleaned up&quot;);&#10;    }&#10;&#10;    //  Configuration File Updater&#10;    public Configuration cfg = this.getConfig().getDefaults();&#10;    public void updateConfig() {&#10;        try {&#10;            if(new File(getDataFolder() + &quot;/config.yml&quot;).exists()) {&#10;                boolean changesMade = false;&#10;                YamlConfiguration tmp = new YamlConfiguration();&#10;                tmp.load(getDataFolder() + &quot;/config.yml&quot;);&#10;                for(String str : cfg.getKeys(true)) {&#10;                    if(!tmp.getKeys(true).contains(str)) {&#10;                        tmp.set(str, cfg.get(str));&#10;                        changesMade = true;&#10;                    }&#10;                }&#10;                if(changesMade)&#10;                    tmp.save(getDataFolder() + &quot;/config.yml&quot;);&#10;            }&#10;        } catch (IOException | InvalidConfigurationException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package loyfael.antiVillagerLag;&#10;&#10;import org.bstats.bukkit.Metrics;&#10;import org.bstats.charts.MultiLineChart;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.configuration.Configuration;&#10;import org.bukkit.configuration.InvalidConfigurationException;&#10;import org.bukkit.configuration.file.YamlConfiguration;&#10;import org.bukkit.plugin.java.JavaPlugin;&#10;import loyfael.antiVillagerLag.commands.OptimizeCommand;&#10;import loyfael.antiVillagerLag.commands.ReloadCommand;&#10;import loyfael.antiVillagerLag.commands.RemoveChangesCommand;&#10;import loyfael.antiVillagerLag.commands.UnoptimizeCommand;&#10;import loyfael.antiVillagerLag.commands.StatusCommand;&#10;import loyfael.antiVillagerLag.commands.InfoCommand;&#10;import loyfael.antiVillagerLag.events.EventListener;&#10;import loyfael.antiVillagerLag.utils.UpdateChecker;&#10;import loyfael.antiVillagerLag.utils.VillagerUtilities;&#10;import loyfael.antiVillagerLag.utils.TaskManager;&#10;import loyfael.antiVillagerLag.utils.VillagerCache;&#10;&#10;import java.io.File;&#10;import java.io.IOException;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public final class AntiVillagerLag extends JavaPlugin {&#10;&#10;    @Override&#10;    public void onEnable() {&#10;&#10;        // Initialisation des optimisations de performance&#10;        VillagerUtilities.initializeKeys(this);&#10;        TaskManager.initialize(this);&#10;&#10;        //  Command Registration&#10;        getCommand(&quot;avlreload&quot;).setExecutor(new ReloadCommand(this));&#10;        getCommand(&quot;avloptimize&quot;).setExecutor(new OptimizeCommand(this));&#10;        getCommand(&quot;avlunoptimize&quot;).setExecutor(new UnoptimizeCommand(this));&#10;        getCommand(&quot;avlremove&quot;).setExecutor(new RemoveChangesCommand(this));&#10;        getCommand(&quot;avlstatus&quot;).setExecutor(new StatusCommand(this));&#10;        getCommand(&quot;avlinfo&quot;).setExecutor(new InfoCommand(this));&#10;&#10;        //  Event Registration&#10;        getServer().getPluginManager().registerEvents(new EventListener(this), this);&#10;&#10;        //  Config Stuff&#10;        saveDefaultConfig();&#10;        updateConfig();&#10;&#10;        // Chargement optimisé des configurations (async si possible)&#10;        TaskManager.runAsync(() -&gt; {&#10;            VillagerUtilities.updateNameTags(this);&#10;            VillagerUtilities.updateStandingOnBlocks(this);&#10;            VillagerUtilities.updateWorkstationBlocks(this);&#10;            VillagerUtilities.updateRestockTimes(this);&#10;        }).thenRun(() -&gt; {&#10;            getLogger().info(&quot;AntiVillagerLag optimizations loaded - ready for 2000+ villagers!&quot;);&#10;        });&#10;&#10;        //  Bstats Code&#10;        int pluginId = 15890;&#10;        Metrics metrics = new Metrics(this, pluginId);&#10;        //  Optional: Add custom charts&#10;        metrics.addCustomChart(new MultiLineChart(&quot;players_and_servers&quot;, () -&gt; {&#10;            Map&lt;String, Integer&gt; valueMap = new HashMap&lt;&gt;();&#10;            valueMap.put(&quot;servers&quot;, 1);&#10;            valueMap.put(&quot;players&quot;, Bukkit.getOnlinePlayers().size());&#10;            return valueMap;&#10;        }));&#10;&#10;        //  Check for plugin updates&#10;        new UpdateChecker(this, 102949).getVersion(version -&gt; {&#10;            if (this.getDescription().getVersion().equals(version)) {&#10;                getLogger().info(&quot;AntiVillagerLag is up to date!&quot;);&#10;            } else {&#10;                getLogger().info(&quot;There is an update for AntiVillagerLag! https://www.spigotmc.org/resources/antivillagerlag.102949/&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void onDisable() {&#10;        // Nettoyage des ressources pour éviter les fuites mémoire&#10;        TaskManager.shutdown();&#10;        VillagerCache.clearCache();&#10;&#10;        getLogger().info(&quot;AntiVillagerLag optimizations cleaned up&quot;);&#10;    }&#10;&#10;    //  Configuration File Updater&#10;    public Configuration cfg = this.getConfig().getDefaults();&#10;    public void updateConfig() {&#10;        try {&#10;            if(new File(getDataFolder() + &quot;/config.yml&quot;).exists()) {&#10;                boolean changesMade = false;&#10;                YamlConfiguration tmp = new YamlConfiguration();&#10;                tmp.load(getDataFolder() + &quot;/config.yml&quot;);&#10;                for(String str : cfg.getKeys(true)) {&#10;                    if(!tmp.getKeys(true).contains(str)) {&#10;                        tmp.set(str, cfg.get(str));&#10;                        changesMade = true;&#10;                    }&#10;                }&#10;                if(changesMade)&#10;                    tmp.save(getDataFolder() + &quot;/config.yml&quot;);&#10;            }&#10;        } catch (IOException | InvalidConfigurationException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/commands/InfoCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/commands/InfoCommand.java" />
              <option name="originalContent" value="package loyfael.antiVillagerLag.commands;&#10;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.entity.Player;&#10;import loyfael.antiVillagerLag.AntiVillagerLag;&#10;import loyfael.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class InfoCommand implements CommandExecutor {&#10;&#10;    private final AntiVillagerLag plugin;&#10;&#10;    public InfoCommand(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {&#10;        if (!(sender instanceof Player)) {&#10;            sender.sendMessage(&quot;Cette commande ne peut être utilisée que par un joueur.&quot;);&#10;            return true;&#10;        }&#10;&#10;        Player player = (Player) sender;&#10;&#10;        // Display plugin information and usage guide&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;a&amp;l=== AntiVillagerLag - Guide d'utilisation ===&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;e &amp;7Comment optimiser les villagers :&quot;));&#10;&#10;        if (plugin.getConfig().getBoolean(&quot;toggleableoptions.userenaming&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;a  ✓ &amp;7Nommez avec un nametag : &amp;e'Optimize'&quot;));&#10;        }&#10;        if (plugin.getConfig().getBoolean(&quot;toggleableoptions.useblocks&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;a  ✓ &amp;7Placez sur un bloc : &amp;eDiamond/Emerald Block&quot;));&#10;        }&#10;        if (plugin.getConfig().getBoolean(&quot;toggleableoptions.useworkstations&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;a  ✓ &amp;7Près d'une workstation (rayon &quot; +&#10;                plugin.getConfig().getInt(&quot;toggleableoptions.workstationcheckradius&quot;) + &quot; blocs)&quot;));&#10;        }&#10;&#10;        player.sendMessage(&quot;&quot;);&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;6 &amp;7États des villagers :&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;a  [OPTIMIZED] &amp;7- IA désactivée, prêt pour le commerce&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;e  [ACTIVE] &amp;7- IA activée, peut se déplacer/reproduire&quot;));&#10;&#10;        player.sendMessage(&quot;&quot;);&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;c⏰ &amp;7Cooldown : &amp;e&quot; +&#10;            (plugin.getConfig().getLong(&quot;ai-toggle-cooldown&quot;) / 60) + &quot; minutes&quot;));&#10;&#10;        if (player.hasPermission(&quot;avl.commands&quot;)) {&#10;            player.sendMessage(&quot;&quot;);&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;b &amp;7Commandes disponibles :&quot;));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;b  /avloptimize &lt;rayon&gt; &amp;7- Optimise tous les villagers&quot;));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;b  /avlstatus &amp;7- Statistiques du plugin&quot;));&#10;        }&#10;&#10;        return true;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package loyfael.antiVillagerLag.commands;&#10;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.entity.Player;&#10;import loyfael.antiVillagerLag.AntiVillagerLag;&#10;import loyfael.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class InfoCommand implements CommandExecutor {&#10;&#10;    private final AntiVillagerLag plugin;&#10;&#10;    public InfoCommand(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {&#10;        if (!(sender instanceof Player)) {&#10;            sender.sendMessage(&quot;This command can only be used by a player.&quot;);&#10;            return true;&#10;        }&#10;&#10;        Player player = (Player) sender;&#10;&#10;        // Display plugin information and usage guide&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;a&amp;l=== AntiVillagerLag - Usage Guide ===&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;e &amp;7How to optimize villagers:&quot;));&#10;&#10;        if (plugin.getConfig().getBoolean(&quot;toggleableoptions.userenaming&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;a  ✓ &amp;7Name with nametag: &amp;e'Optimize'&quot;));&#10;        }&#10;        if (plugin.getConfig().getBoolean(&quot;toggleableoptions.useblocks&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;a  ✓ &amp;7Place on block: &amp;eDiamond/Emerald Block&quot;));&#10;        }&#10;        if (plugin.getConfig().getBoolean(&quot;toggleableoptions.useworkstations&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;a  ✓ &amp;7Near a workstation (radius &quot; +&#10;                plugin.getConfig().getInt(&quot;toggleableoptions.workstationcheckradius&quot;) + &quot; blocks)&quot;));&#10;        }&#10;&#10;        player.sendMessage(&quot;&quot;);&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;6 &amp;7Villager states:&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;a  [OPTIMIZED] &amp;7- AI disabled, ready for trading&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;e  [ACTIVE] &amp;7- AI enabled, can move/breed&quot;));&#10;&#10;        player.sendMessage(&quot;&quot;);&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;c⏰ &amp;7Cooldown: &amp;e&quot; +&#10;            (plugin.getConfig().getLong(&quot;ai-toggle-cooldown&quot;) / 60) + &quot; minutes&quot;));&#10;&#10;        if (player.hasPermission(&quot;avl.commands&quot;)) {&#10;            player.sendMessage(&quot;&quot;);&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;b &amp;7Available commands:&quot;));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;b  /avloptimize &lt;radius&gt; &amp;7- Optimize all villagers&quot;));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;b  /avlstatus &amp;7- Plugin statistics&quot;));&#10;        }&#10;&#10;        return true;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/commands/OptimizeCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/commands/OptimizeCommand.java" />
              <option name="originalContent" value="package loyfael.antiVillagerLag.commands;&#10;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.entity.Entity;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import loyfael.antiVillagerLag.AntiVillagerLag;&#10;import loyfael.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class OptimizeCommand implements CommandExecutor {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;    public OptimizeCommand(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender commandSender, Command command, String s, String[] strings) {&#10;        if (!command.getName().equalsIgnoreCase(&quot;avloptimize&quot;)) return true;&#10;        //  Make sure it's a player&#10;        if (!(commandSender instanceof Player)) return false;&#10;        Player player = (Player) commandSender;&#10;&#10;        //  Check if they have permission&#10;        if(!player.hasPermission(&quot;avl.optimize&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.no-permission&quot;)));&#10;            return true;&#10;        }&#10;&#10;        //searchable radius based on first argument specified, if null defaults to config&#10;        int radius;&#10;        try{&#10;            radius = (strings != null &amp;&amp; strings.length &gt; 0) ? Integer.parseInt(strings[0]) : plugin.getConfig().getInt(&quot;RadiusDefault&quot;);&#10;        } catch (NumberFormatException e) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-invalid&quot;)));&#10;            return true;&#10;        }&#10;        boolean canSearchRadius = radius &lt;= plugin.getConfig().getInt(&quot;RadiusLimit&quot;);&#10;        if(!canSearchRadius){&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-limit&quot;)).replace(&quot;%avlradiuslimit%&quot;, plugin.getConfig().getString(&quot;RadiusLimit&quot;)));&#10;            return true;&#10;        }&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.searching-radius&quot;)).replace(&quot;%avlradius%&quot;, String.valueOf(radius)));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.bulk-optimize-start&quot;)));&#10;&#10;        // Counter for optimized villagers&#10;        int optimizedCount = 0;&#10;&#10;        // Search for nearby villagers&#10;        for (Entity entity : player.getNearbyEntities(radius, radius, radius)) {&#10;            if (entity instanceof Villager) {&#10;                Villager villager = (Villager) entity;&#10;                //  Setup new Villagers&#10;                if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;                    VillagerUtilities.setAiCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLevelCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLastRestock(villager, plugin);&#10;                    VillagerUtilities.setMarker(villager, plugin, true);&#10;                }&#10;&#10;                // Only optimize if not already optimized&#10;                if (VillagerUtilities.getMarker(villager, plugin)) {&#10;                    //  Rename villager&#10;                    villager.setCustomName(VillagerUtilities.disabling_names.getFirst());&#10;                    //  Update the marker and AI&#10;                    VillagerUtilities.setMarker(villager, plugin, false);&#10;                    villager.setAware(false);&#10;                    optimizedCount++;&#10;                }&#10;            }&#10;        }&#10;&#10;        // Send completion message with statistics&#10;        String completeMsg = plugin.getConfig().getString(&quot;messages.bulk-optimize-complete&quot;);&#10;        completeMsg = completeMsg.replace(&quot;%avlcount%&quot;, String.valueOf(optimizedCount));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(completeMsg));&#10;&#10;        // Calculate and show performance impact&#10;        if (optimizedCount &gt; 0) {&#10;            int estimatedPerformanceGain = Math.min(90, optimizedCount * 2); // Rough estimate: 2% per villager, max 90%&#10;            String performanceMsg = plugin.getConfig().getString(&quot;messages.performance-impact&quot;);&#10;            performanceMsg = performanceMsg.replace(&quot;%avlpercentage%&quot;, String.valueOf(estimatedPerformanceGain));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(performanceMsg));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-zombie-protected&quot;)));&#10;        }&#10;        return true;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package loyfael.antiVillagerLag.commands;&#10;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.entity.Entity;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import loyfael.antiVillagerLag.AntiVillagerLag;&#10;import loyfael.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class OptimizeCommand implements CommandExecutor {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;    public OptimizeCommand(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender commandSender, Command command, String s, String[] strings) {&#10;        if (!command.getName().equalsIgnoreCase(&quot;avloptimize&quot;)) return true;&#10;        //  Make sure it's a player&#10;        if (!(commandSender instanceof Player)) return false;&#10;        Player player = (Player) commandSender;&#10;&#10;        //  Check if they have permission&#10;        if(!player.hasPermission(&quot;avl.optimize&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.no-permission&quot;)));&#10;            return true;&#10;        }&#10;&#10;        //searchable radius based on first argument specified, if null defaults to config&#10;        int radius;&#10;        try{&#10;            radius = (strings != null &amp;&amp; strings.length &gt; 0) ? Integer.parseInt(strings[0]) : plugin.getConfig().getInt(&quot;RadiusDefault&quot;);&#10;        } catch (NumberFormatException e) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-invalid&quot;)));&#10;            return true;&#10;        }&#10;        boolean canSearchRadius = radius &lt;= plugin.getConfig().getInt(&quot;RadiusLimit&quot;);&#10;        if(!canSearchRadius){&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-limit&quot;)).replace(&quot;%avlradiuslimit%&quot;, plugin.getConfig().getString(&quot;RadiusLimit&quot;)));&#10;            return true;&#10;        }&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.searching-radius&quot;)).replace(&quot;%avlradius%&quot;, String.valueOf(radius)));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.bulk-optimize-start&quot;)));&#10;&#10;        // Counter for optimized villagers&#10;        int optimizedCount = 0;&#10;&#10;        // Search for nearby villagers&#10;        for (Entity entity : player.getNearbyEntities(radius, radius, radius)) {&#10;            if (entity instanceof Villager) {&#10;                Villager villager = (Villager) entity;&#10;                //  Setup new Villagers&#10;                if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;                    VillagerUtilities.setAiCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLevelCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLastRestock(villager, plugin);&#10;                    VillagerUtilities.setMarker(villager, plugin, true);&#10;                }&#10;&#10;                // Only optimize if not already optimized&#10;                if (VillagerUtilities.getMarker(villager, plugin)) {&#10;                    //  Rename villager - correction pour Set au lieu de List&#10;                    if (!VillagerUtilities.disabling_names.isEmpty()) {&#10;                        String firstName = VillagerUtilities.disabling_names.iterator().next();&#10;                        villager.setCustomName(firstName);&#10;                    }&#10;                    //  Update the marker and AI&#10;                    VillagerUtilities.setMarker(villager, plugin, false);&#10;                    villager.setAware(false);&#10;                    optimizedCount++;&#10;                }&#10;            }&#10;        }&#10;&#10;        // Send completion message with statistics&#10;        String completeMsg = plugin.getConfig().getString(&quot;messages.bulk-optimize-complete&quot;);&#10;        completeMsg = completeMsg.replace(&quot;%avlcount%&quot;, String.valueOf(optimizedCount));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(completeMsg));&#10;&#10;        // Calculate and show performance impact&#10;        if (optimizedCount &gt; 0) {&#10;            int estimatedPerformanceGain = Math.min(90, optimizedCount * 2); // Rough estimate: 2% per villager, max 90%&#10;            String performanceMsg = plugin.getConfig().getString(&quot;messages.performance-impact&quot;);&#10;            performanceMsg = performanceMsg.replace(&quot;%avlpercentage%&quot;, String.valueOf(estimatedPerformanceGain));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(performanceMsg));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-zombie-protected&quot;)));&#10;        }&#10;        return true;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/events/EventListener.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/events/EventListener.java" />
              <option name="originalContent" value="package loyfael.antiVillagerLag.events;&#10;&#10;import org.bukkit.ChatColor;&#10;import org.bukkit.Material;&#10;import org.bukkit.Particle;&#10;import org.bukkit.Sound;&#10;import org.bukkit.entity.*;&#10;import org.bukkit.event.Listener;&#10;import org.bukkit.event.EventHandler;&#10;import org.bukkit.event.EventPriority;&#10;import org.bukkit.event.entity.EntityDamageByEntityEvent;&#10;import org.bukkit.event.inventory.InventoryClickEvent;&#10;import org.bukkit.event.inventory.InventoryCloseEvent;&#10;import org.bukkit.event.inventory.InventoryType;&#10;import org.bukkit.event.inventory.TradeSelectEvent;&#10;import org.bukkit.event.player.PlayerInteractEntityEvent;&#10;import org.bukkit.event.player.PlayerJoinEvent;&#10;import org.bukkit.inventory.ItemStack;&#10;import loyfael.antiVillagerLag.AntiVillagerLag;&#10;import loyfael.antiVillagerLag.utils.ActionBarUtils;&#10;import loyfael.antiVillagerLag.utils.UpdateChecker;&#10;import loyfael.antiVillagerLag.utils.VillagerUtilities;&#10;import loyfael.antiVillagerLag.utils.VillagerCache;&#10;&#10;public class EventListener implements Listener {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;&#10;    public EventListener(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;&#10;    @EventHandler&#10;    public void onRightClick(PlayerInteractEntityEvent event) {&#10;        if (event.isCancelled()) return;&#10;        Player player = event.getPlayer();&#10;        //  It's a villager&#10;        if (!event.getRightClicked().getType().equals(EntityType.VILLAGER)) return;&#10;        Villager villager = (Villager) event.getRightClicked();&#10;&#10;        //  Setup new Villagers&#10;        if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;            VillagerUtilities.setAiCooldown(villager, plugin, 0L);&#10;            VillagerUtilities.setLevelCooldown(villager, plugin, 0L);&#10;            VillagerUtilities.setLastRestock(villager, plugin);&#10;            VillagerUtilities.setMarker(villager, plugin, true);&#10;        }&#10;&#10;        //  Get Times&#10;        long currentTime = System.currentTimeMillis() / 1000;&#10;        long vilLevelCooldown = VillagerUtilities.getLevelCooldown(villager, plugin);&#10;        long vilAiCooldown = VillagerUtilities.getAiCooldown(villager, plugin);&#10;        long totalSeconds = vilAiCooldown - currentTime;&#10;        long sec = totalSeconds % 60;&#10;        long min = totalSeconds / 60;&#10;&#10;        //  If the villager is leveling up&#10;        if (vilLevelCooldown &gt; currentTime) {&#10;            String message = plugin.getConfig().getString(&quot;messages.cooldown-levelup-message&quot;);&#10;            long level_sec = vilLevelCooldown - currentTime;&#10;            message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(level_sec));&#10;            event.getPlayer().sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;            villager.shakeHead();&#10;            event.setCancelled(true);&#10;            return;&#10;        }&#10;&#10;        //  Should it be disabled?&#10;        boolean nametag_result = NameTagAI.call(villager, plugin, player);&#10;        boolean block_result = BlockAI.call(villager, plugin, player);&#10;        boolean workblock_result = WorkblockAI.call(villager, plugin, player);&#10;        boolean should_be_disabled = nametag_result || block_result || workblock_result;&#10;&#10;&#10;        //  If villager AI is being toggled&#10;        if (should_be_disabled == VillagerUtilities.getMarker(villager, plugin)) {&#10;            //  If toggling is on cooldown&#10;            if ((vilAiCooldown &gt; currentTime) &amp;&amp; !player.hasPermission(&quot;avl.cooldown.bypass&quot;)) {&#10;                //Tell player it's on cooldown with action bar&#10;                ActionBarUtils.sendCooldownInfo(player, min, sec, plugin);&#10;                String message = plugin.getConfig().getString(&quot;messages.cooldown-ai-message&quot;);&#10;                message = message.replaceAll(&quot;%avlminutes%&quot;, Long.toString(min));&#10;                message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(sec));&#10;                event.getPlayer().sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;                event.setCancelled(true);&#10;            //  If cooldown is over&#10;            } else {&#10;                boolean wasOptimized = VillagerUtilities.getMarker(villager, plugin);&#10;                VillagerUtilities.setMarker(villager, plugin, !should_be_disabled);&#10;                villager.setAware(!should_be_disabled);&#10;                VillagerUtilities.setAiCooldown(villager, plugin, plugin.getConfig().getLong(&quot;ai-toggle-cooldown&quot;));&#10;&#10;                // Show visual and audio feedback&#10;                showVillagerStateChange(villager, player, wasOptimized);&#10;&#10;                // Enhanced feedback messages with action bar&#10;                ActionBarUtils.sendVillagerStatus(player, villager, plugin);&#10;                if (!should_be_disabled) {&#10;                    // Villager was optimized, now being unoptimized (activated)&#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-unoptimized&quot;)));&#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-breeding-reminder&quot;)));&#10;                } else {&#10;                    // Villager was active, now being optimized (disabled)&#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-optimized&quot;)));&#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-performance-tip&quot;)));&#10;                }&#10;&#10;                //  If nametag shouldn't be consumed, give one back&#10;                if (player.getInventory().getItemInMainHand().getType().equals(Material.NAME_TAG) &amp;&amp; !plugin.getConfig().getBoolean(&quot;toggleableoptions.usenametags&quot;)) {&#10;                    ItemStack nametag = player.getInventory().getItemInMainHand();&#10;                    if (!nametag.getItemMeta().hasDisplayName()) return;&#10;                    player.getInventory().getItemInMainHand().setAmount(player.getInventory().getItemInMainHand().getAmount() + 1);&#10;                }&#10;            }&#10;        }&#10;        //  If the villager AI is not being toggled&#10;        else {&#10;            // Show current status with action bar&#10;            ActionBarUtils.sendVillagerStatus(player, villager, plugin);&#10;&#10;            //  If nametag shouldn't be consumed, give one back&#10;            if (!VillagerUtilities.hasMarker(villager, plugin)) return;&#10;            if (player.getInventory().getItemInMainHand().getType().equals(Material.NAME_TAG) &amp;&amp; !plugin.getConfig().getBoolean(&quot;toggleableoptions.usenametags&quot;)) {&#10;                ItemStack nametag = player.getInventory().getItemInMainHand();&#10;                if (!nametag.getItemMeta().hasDisplayName()) return;&#10;                player.getInventory().getItemInMainHand().setAmount(player.getInventory().getItemInMainHand().getAmount() + 1);&#10;            }&#10;        }&#10;&#10;        //  Restock&#10;        if (!VillagerUtilities.getMarker(villager, plugin)) {&#10;            RestockVillager.call(villager, plugin, player);&#10;        }&#10;    }&#10;&#10;    // Helper method for visual feedback - optimisé&#10;    private void showVillagerStateChange(Villager villager, Player player, boolean wasOptimized) {&#10;        if (plugin.getConfig().getBoolean(&quot;visual-feedback.enabled&quot;, true)) {&#10;            if (wasOptimized) {&#10;                // Villager activé - particules clouds&#10;                villager.getWorld().spawnParticle(Particle.CLOUD,&#10;                    villager.getLocation().add(0, 1, 0), 5, 0.2, 0.2, 0.2, 0.02);&#10;                player.playSound(player.getLocation(), Sound.ENTITY_VILLAGER_AMBIENT, 0.6f, 1.0f);&#10;            } else {&#10;                // Villager optimisé - particules happy&#10;                villager.getWorld().spawnParticle(Particle.HAPPY_VILLAGER,&#10;                    villager.getLocation().add(0, 1.5, 0), 8, 0.3, 0.3, 0.3, 0.05);&#10;                player.playSound(player.getLocation(), Sound.ENTITY_EXPERIENCE_ORB_PICKUP, 0.5f, 1.1f);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Méthodes utilitaires ultra-optimisées&#10;    private void showVillagerStatus(Player player, Villager villager, VillagerCache.VillagerData data) {&#10;        ActionBarUtils.sendVillagerStatus(player, villager, plugin);&#10;&#10;        if (data.aiState) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&#10;                plugin.getConfig().getString(&quot;messages.villager-status-optimized&quot;)));&#10;        } else {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&#10;                plugin.getConfig().getString(&quot;messages.villager-status-active&quot;)));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&#10;                plugin.getConfig().getString(&quot;messages.action-help&quot;)));&#10;        }&#10;    }&#10;&#10;    private void sendOptimizedFeedbackMessage(Player player, boolean wasOptimized) {&#10;        if (wasOptimized) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&#10;                plugin.getConfig().getString(&quot;messages.villager-optimized&quot;)));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&#10;                plugin.getConfig().getString(&quot;messages.villager-performance-tip&quot;)));&#10;        } else {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&#10;                plugin.getConfig().getString(&quot;messages.villager-unoptimized&quot;)));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&#10;                plugin.getConfig().getString(&quot;messages.villager-breeding-reminder&quot;)));&#10;        }&#10;    }&#10;&#10;    // Events optimisés avec priorité et filtrage rapide&#10;    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)&#10;    public void inventoryMove(InventoryClickEvent event) {&#10;        // Vérifications rapides en premier&#10;        if (!(event.getInventory().getHolder() instanceof Villager)) return;&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.preventtrading&quot;)) return;&#10;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        VillagerCache.VillagerData data = VillagerCache.getVillagerData(vil, plugin);&#10;&#10;        if (data == null || !data.aiState) return;&#10;&#10;        Player player = (Player) event.getWhoClicked();&#10;        event.setCancelled(true);&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&#10;            plugin.getConfig().getString(&quot;messages.VillagerMustBeDisabled&quot;)));&#10;    }&#10;&#10;    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)&#10;    public void villagerTradeClick(TradeSelectEvent event) {&#10;        if (!(event.getInventory().getHolder() instanceof Villager)) return;&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.preventtrading&quot;)) return;&#10;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        VillagerCache.VillagerData data = VillagerCache.getVillagerData(vil, plugin);&#10;&#10;        if (data == null || !data.aiState) return;&#10;&#10;        Player player = (Player) event.getWhoClicked();&#10;        event.setCancelled(true);&#10;        player.closeInventory();&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&#10;            plugin.getConfig().getString(&quot;messages.VillagerMustBeDisabled&quot;)));&#10;    }&#10;&#10;    // Optimisation critique - utiliser le cache au lieu de PersistentData&#10;    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)&#10;    public void onCancelVillagerDamage(EntityDamageByEntityEvent event) {&#10;        if (!(event.getEntity() instanceof Villager &amp;&amp; event.getDamager() instanceof Zombie)) return;&#10;&#10;        Villager vil = (Villager) event.getEntity();&#10;        VillagerCache.VillagerData data = VillagerCache.getVillagerData(vil, plugin);&#10;&#10;        // Protéger seulement les villagers optimisés (AI disabled)&#10;        if (data != null &amp;&amp; !data.aiState) {&#10;            event.setCancelled(true);&#10;        }&#10;    }&#10;&#10;    @EventHandler&#10;    public void playerJoin(PlayerJoinEvent event) {&#10;        if (!event.getPlayer().hasPermission(&quot;avl.notify.update&quot;)) return;&#10;        new UpdateChecker(plugin, 102949).getVersion(version -&gt; {&#10;            if (plugin.getDescription().getVersion().equals(version)) {&#10;                event.getPlayer().sendMessage(ChatColor.GREEN + &quot;AntiVillagerLag is up to date!&quot;);&#10;            } else {&#10;                event.getPlayer().sendMessage(ChatColor.GREEN + &quot;There is an update for AntiVillagerLag! https://www.spigotmc.org/resources/antivillagerlag.102949/&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    // Event to handle Villager updating&#10;    @EventHandler&#10;    public void afterTrade(InventoryCloseEvent event) {&#10;&#10;        Player player = (Player) event.getPlayer();&#10;        if(player.hasPermission(&quot;avl.disable&quot;))&#10;            return;&#10;        // check if inventory belongs to a Villager Trade Screen&#10;        if (event.getInventory().getHolder() == null) return;&#10;        if (event.getInventory().getHolder() instanceof WanderingTrader) return;&#10;        if(event.getInventory().getType() != InventoryType.MERCHANT) return;&#10;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        // make sure the villager is disabled&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (VillagerUtilities.getMarker(vil, plugin)) return;&#10;&#10;        // handle leveling&#10;        VillagerLevelManager.call(vil, plugin, player);&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package loyfael.antiVillagerLag.events;&#10;&#10;import org.bukkit.ChatColor;&#10;import org.bukkit.Material;&#10;import org.bukkit.Particle;&#10;import org.bukkit.Sound;&#10;import org.bukkit.entity.*;&#10;import org.bukkit.event.Listener;&#10;import org.bukkit.event.EventHandler;&#10;import org.bukkit.event.EventPriority;&#10;import org.bukkit.event.entity.EntityDamageByEntityEvent;&#10;import org.bukkit.event.inventory.InventoryClickEvent;&#10;import org.bukkit.event.inventory.InventoryCloseEvent;&#10;import org.bukkit.event.inventory.InventoryType;&#10;import org.bukkit.event.inventory.TradeSelectEvent;&#10;import org.bukkit.event.player.PlayerInteractEntityEvent;&#10;import org.bukkit.event.player.PlayerJoinEvent;&#10;import org.bukkit.inventory.ItemStack;&#10;import loyfael.antiVillagerLag.AntiVillagerLag;&#10;import loyfael.antiVillagerLag.utils.ActionBarUtils;&#10;import loyfael.antiVillagerLag.utils.UpdateChecker;&#10;import loyfael.antiVillagerLag.utils.VillagerUtilities;&#10;import loyfael.antiVillagerLag.utils.VillagerCache;&#10;&#10;public class EventListener implements Listener {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;&#10;    public EventListener(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;&#10;    @EventHandler&#10;    public void onRightClick(PlayerInteractEntityEvent event) {&#10;        if (event.isCancelled()) return;&#10;        Player player = event.getPlayer();&#10;        //  It's a villager&#10;        if (!event.getRightClicked().getType().equals(EntityType.VILLAGER)) return;&#10;        Villager villager = (Villager) event.getRightClicked();&#10;&#10;        //  Setup new Villagers&#10;        if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;            VillagerUtilities.setAiCooldown(villager, plugin, 0L);&#10;            VillagerUtilities.setLevelCooldown(villager, plugin, 0L);&#10;            VillagerUtilities.setLastRestock(villager, plugin);&#10;            VillagerUtilities.setMarker(villager, plugin, true);&#10;        }&#10;&#10;        //  Get Times&#10;        long currentTime = System.currentTimeMillis() / 1000;&#10;        long vilLevelCooldown = VillagerUtilities.getLevelCooldown(villager, plugin);&#10;        long vilAiCooldown = VillagerUtilities.getAiCooldown(villager, plugin);&#10;        long totalSeconds = vilAiCooldown - currentTime;&#10;        long sec = totalSeconds % 60;&#10;        long min = totalSeconds / 60;&#10;&#10;        //  If the villager is leveling up&#10;        if (vilLevelCooldown &gt; currentTime) {&#10;            String message = plugin.getConfig().getString(&quot;messages.cooldown-levelup-message&quot;);&#10;            long level_sec = vilLevelCooldown - currentTime;&#10;            message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(level_sec));&#10;            event.getPlayer().sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;            villager.shakeHead();&#10;            event.setCancelled(true);&#10;            return;&#10;        }&#10;&#10;        //  Should it be disabled?&#10;        boolean nametag_result = NameTagAI.call(villager, plugin, player);&#10;        boolean block_result = BlockAI.call(villager, plugin, player);&#10;        boolean workblock_result = WorkblockAI.call(villager, plugin, player);&#10;        boolean should_be_disabled = nametag_result || block_result || workblock_result;&#10;&#10;&#10;        //  If villager AI is being toggled&#10;        if (should_be_disabled == VillagerUtilities.getMarker(villager, plugin)) {&#10;            //  If toggling is on cooldown&#10;            if ((vilAiCooldown &gt; currentTime) &amp;&amp; !player.hasPermission(&quot;avl.cooldown.bypass&quot;)) {&#10;                //Tell player it's on cooldown with action bar&#10;                ActionBarUtils.sendCooldownInfo(player, min, sec, plugin);&#10;                String message = plugin.getConfig().getString(&quot;messages.cooldown-ai-message&quot;);&#10;                message = message.replaceAll(&quot;%avlminutes%&quot;, Long.toString(min));&#10;                message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(sec));&#10;                event.getPlayer().sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;                event.setCancelled(true);&#10;            //  If cooldown is over&#10;            } else {&#10;                boolean wasOptimized = VillagerUtilities.getMarker(villager, plugin);&#10;                VillagerUtilities.setMarker(villager, plugin, !should_be_disabled);&#10;                villager.setAware(!should_be_disabled);&#10;                VillagerUtilities.setAiCooldown(villager, plugin, plugin.getConfig().getLong(&quot;ai-toggle-cooldown&quot;));&#10;&#10;                // Show visual and audio feedback&#10;                showVillagerStateChange(villager, player, wasOptimized);&#10;&#10;                // Enhanced feedback messages with action bar&#10;                ActionBarUtils.sendVillagerStatus(player, villager, plugin);&#10;                if (!should_be_disabled) {&#10;                    // Villager was optimized, now being unoptimized (activated)&#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-unoptimized&quot;)));&#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-breeding-reminder&quot;)));&#10;                } else {&#10;                    // Villager was active, now being optimized (disabled)&#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-optimized&quot;)));&#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-performance-tip&quot;)));&#10;                }&#10;&#10;                //  If nametag shouldn't be consumed, give one back&#10;                if (player.getInventory().getItemInMainHand().getType().equals(Material.NAME_TAG) &amp;&amp; !plugin.getConfig().getBoolean(&quot;toggleableoptions.usenametags&quot;)) {&#10;                    ItemStack nametag = player.getInventory().getItemInMainHand();&#10;                    if (!nametag.getItemMeta().hasDisplayName()) return;&#10;                    player.getInventory().getItemInMainHand().setAmount(player.getInventory().getItemInMainHand().getAmount() + 1);&#10;                }&#10;            }&#10;        }&#10;        //  If the villager AI is not being toggled&#10;        else {&#10;            // Show current status with action bar&#10;            ActionBarUtils.sendVillagerStatus(player, villager, plugin);&#10;&#10;            //  If nametag shouldn't be consumed, give one back&#10;            if (!VillagerUtilities.hasMarker(villager, plugin)) return;&#10;            if (player.getInventory().getItemInMainHand().getType().equals(Material.NAME_TAG) &amp;&amp; !plugin.getConfig().getBoolean(&quot;toggleableoptions.usenametags&quot;)) {&#10;                ItemStack nametag = player.getInventory().getItemInMainHand();&#10;                if (!nametag.getItemMeta().hasDisplayName()) return;&#10;                player.getInventory().getItemInMainHand().setAmount(player.getInventory().getItemInMainHand().getAmount() + 1);&#10;            }&#10;        }&#10;&#10;        //  Restock&#10;        if (!VillagerUtilities.getMarker(villager, plugin)) {&#10;            RestockVillager.call(villager, plugin, player);&#10;        }&#10;    }&#10;&#10;    // Helper method for visual feedback - optimisé&#10;    private void showVillagerStateChange(Villager villager, Player player, boolean wasOptimized) {&#10;        if (plugin.getConfig().getBoolean(&quot;visual-feedback.enabled&quot;, true)) {&#10;            if (wasOptimized) {&#10;                // Villager activé - particules clouds&#10;                villager.getWorld().spawnParticle(Particle.CLOUD,&#10;                    villager.getLocation().add(0, 1, 0), 5, 0.2, 0.2, 0.2, 0.02);&#10;                player.playSound(player.getLocation(), Sound.ENTITY_VILLAGER_AMBIENT, 0.6f, 1.0f);&#10;            } else {&#10;                // Villager optimisé - particules happy&#10;                villager.getWorld().spawnParticle(Particle.HAPPY_VILLAGER,&#10;                    villager.getLocation().add(0, 1.5, 0), 8, 0.3, 0.3, 0.3, 0.05);&#10;                player.playSound(player.getLocation(), Sound.ENTITY_EXPERIENCE_ORB_PICKUP, 0.5f, 1.1f);&#10;            }&#10;        }&#10;    }&#10;&#10;    // Méthodes utilitaires ultra-optimisées&#10;    private void showVillagerStatus(Player player, Villager villager, VillagerCache.VillagerData data) {&#10;        ActionBarUtils.sendVillagerStatus(player, villager, plugin);&#10;&#10;        if (data.aiState) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&#10;                plugin.getConfig().getString(&quot;messages.villager-status-optimized&quot;)));&#10;        } else {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&#10;                plugin.getConfig().getString(&quot;messages.villager-status-active&quot;)));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&#10;                plugin.getConfig().getString(&quot;messages.action-help&quot;)));&#10;        }&#10;    }&#10;&#10;    private void sendOptimizedFeedbackMessage(Player player, boolean wasOptimized) {&#10;        if (wasOptimized) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&#10;                plugin.getConfig().getString(&quot;messages.villager-optimized&quot;)));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&#10;                plugin.getConfig().getString(&quot;messages.villager-performance-tip&quot;)));&#10;        } else {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&#10;                plugin.getConfig().getString(&quot;messages.villager-unoptimized&quot;)));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&#10;                plugin.getConfig().getString(&quot;messages.villager-breeding-reminder&quot;)));&#10;        }&#10;    }&#10;&#10;    // Events optimisés avec priorité et filtrage rapide&#10;    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)&#10;    public void inventoryMove(InventoryClickEvent event) {&#10;        // Vérifications rapides en premier&#10;        if (!(event.getInventory().getHolder() instanceof Villager)) return;&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.preventtrading&quot;)) return;&#10;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        VillagerCache.VillagerData data = VillagerCache.getVillagerData(vil, plugin);&#10;&#10;        if (data == null || !data.aiState) return;&#10;&#10;        Player player = (Player) event.getWhoClicked();&#10;        event.setCancelled(true);&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&#10;            plugin.getConfig().getString(&quot;messages.VillagerMustBeDisabled&quot;)));&#10;    }&#10;&#10;    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)&#10;    public void villagerTradeClick(TradeSelectEvent event) {&#10;        if (!(event.getInventory().getHolder() instanceof Villager)) return;&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.preventtrading&quot;)) return;&#10;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        VillagerCache.VillagerData data = VillagerCache.getVillagerData(vil, plugin);&#10;&#10;        if (data == null || !data.aiState) return;&#10;&#10;        Player player = (Player) event.getWhoClicked();&#10;        event.setCancelled(true);&#10;        player.closeInventory();&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&#10;            plugin.getConfig().getString(&quot;messages.VillagerMustBeDisabled&quot;)));&#10;    }&#10;&#10;    // Optimisation critique - utiliser le cache au lieu de PersistentData&#10;    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)&#10;    public void onCancelVillagerDamage(EntityDamageByEntityEvent event) {&#10;        if (!(event.getEntity() instanceof Villager &amp;&amp; event.getDamager() instanceof Zombie)) return;&#10;&#10;        Villager vil = (Villager) event.getEntity();&#10;        VillagerCache.VillagerData data = VillagerCache.getVillagerData(vil, plugin);&#10;&#10;        // Protéger seulement les villagers optimisés (AI disabled)&#10;        if (data != null &amp;&amp; !data.aiState) {&#10;            event.setCancelled(true);&#10;        }&#10;    }&#10;&#10;    @EventHandler&#10;    public void playerJoin(PlayerJoinEvent event) {&#10;        if (!event.getPlayer().hasPermission(&quot;avl.notify.update&quot;)) return;&#10;        new UpdateChecker(plugin, 102949).getVersion(version -&gt; {&#10;            if (plugin.getDescription().getVersion().equals(version)) {&#10;                event.getPlayer().sendMessage(ChatColor.GREEN + &quot;AntiVillagerLag is up to date!&quot;);&#10;            } else {&#10;                event.getPlayer().sendMessage(ChatColor.GREEN + &quot;There is an update for AntiVillagerLag! https://www.spigotmc.org/resources/antivillagerlag.102949/&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    // Event to handle Villager updating&#10;    @EventHandler&#10;    public void afterTrade(InventoryCloseEvent event) {&#10;&#10;        Player player = (Player) event.getPlayer();&#10;        if(player.hasPermission(&quot;avl.disable&quot;))&#10;            return;&#10;        // check if inventory belongs to a Villager Trade Screen&#10;        if (event.getInventory().getHolder() == null) return;&#10;        if (event.getInventory().getHolder() instanceof WanderingTrader) return;&#10;        if(event.getInventory().getType() != InventoryType.MERCHANT) return;&#10;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        // make sure the villager is disabled&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (VillagerUtilities.getMarker(vil, plugin)) return;&#10;&#10;        // handle leveling&#10;        VillagerLevelManager.call(vil, plugin, player);&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/events/WorkblockAI.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/events/WorkblockAI.java" />
              <option name="originalContent" value="package loyfael.antiVillagerLag.events;&#10;&#10;import org.bukkit.Location;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import loyfael.antiVillagerLag.AntiVillagerLag;&#10;import loyfael.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class WorkblockAI {&#10;&#10;    public static boolean call(Villager villager, AntiVillagerLag plugin, Player player) {&#10;        //check if workstation is disabled&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.useworkstations&quot;)) return false;&#10;&#10;        int radius = plugin.getConfig().getInt(&quot;toggleableoptions.workstationcheckradius&quot;);&#10;        // Check for blocks within the specified radius&#10;        for (int x = -radius; x &lt;= radius; x++) {&#10;            for (int y = -radius; y &lt;= radius; y++) {&#10;                for (int z = -radius; z &lt;= radius; z++) {&#10;                    Location blockLocation = new Location(villager.getWorld(), villager.getLocation().getX() + x, villager.getLocation().getY() + y, villager.getLocation().getZ() + z);&#10;                    if (VillagerUtilities.standingon_blocks.contains(blockLocation.getBlock().getType())) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package loyfael.antiVillagerLag.events;&#10;&#10;import org.bukkit.Location;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import loyfael.antiVillagerLag.AntiVillagerLag;&#10;import loyfael.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class WorkblockAI {&#10;&#10;    public static boolean call(Villager villager, AntiVillagerLag plugin, Player player) {&#10;        //check if workstation is disabled&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.useworkstations&quot;)) return false;&#10;&#10;        int radius = plugin.getConfig().getInt(&quot;toggleableoptions.workstationcheckradius&quot;);&#10;        // Check for blocks within the specified radius&#10;        for (int x = -radius; x &lt;= radius; x++) {&#10;            for (int y = -radius; y &lt;= radius; y++) {&#10;                for (int z = -radius; z &lt;= radius; z++) {&#10;                    Location blockLocation = new Location(villager.getWorld(), villager.getLocation().getX() + x, villager.getLocation().getY() + y, villager.getLocation().getZ() + z);&#10;                    if (VillagerUtilities.standingon_blocks.contains(blockLocation.getBlock().getType())) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/utils/ActionBarUtils.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/utils/ActionBarUtils.java" />
              <option name="updatedContent" value="package loyfael.antiVillagerLag.utils;&#10;&#10;import net.md_5.bungee.api.ChatMessageType;&#10;import net.md_5.bungee.api.chat.TextComponent;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import loyfael.antiVillagerLag.AntiVillagerLag;&#10;&#10;public class ActionBarUtils {&#10;&#10;    public static void sendVillagerStatus(Player player, Villager villager, AntiVillagerLag plugin) {&#10;        if (!plugin.getConfig().getBoolean(&quot;action-bar.enabled&quot;, true)) return;&#10;        &#10;        String message;&#10;        if (VillagerUtilities.hasMarker(villager, plugin)) {&#10;            if (VillagerUtilities.getMarker(villager, plugin)) {&#10;                // Villager is optimized (AI disabled)&#10;                message = plugin.getConfig().getString(&quot;action-bar.status-optimized&quot;, &quot;&amp;a[OPTIMIZED] &amp;7Ready for trading&quot;);&#10;            } else {&#10;                // Villager is active (AI enabled)&#10;                message = plugin.getConfig().getString(&quot;action-bar.status-active&quot;, &quot;&amp;e[ACTIVE] &amp;7Mobile villager&quot;);&#10;            }&#10;        } else {&#10;            message = plugin.getConfig().getString(&quot;action-bar.status-new&quot;, &quot;&amp;7[NEW] &amp;eRight-click to setup&quot;);&#10;        }&#10;        &#10;        message = VillagerUtilities.colorcodes.cm(message);&#10;        player.spigot().sendMessage(ChatMessageType.ACTION_BAR, new TextComponent(message));&#10;    }&#10;    &#10;    public static void sendCooldownInfo(Player player, long minutes, long seconds, AntiVillagerLag plugin) {&#10;        if (!plugin.getConfig().getBoolean(&quot;action-bar.enabled&quot;, true)) return;&#10;        &#10;        String message = plugin.getConfig().getString(&quot;action-bar.cooldown&quot;, &quot;&amp;c⏰ Cooldown: %avlminutes%m %avlseconds%s&quot;);&#10;        message = message.replaceAll(&quot;%avlminutes%&quot;, String.valueOf(minutes));&#10;        message = message.replaceAll(&quot;%avlseconds%&quot;, String.valueOf(seconds));&#10;        message = VillagerUtilities.colorcodes.cm(message);&#10;        &#10;        player.spigot().sendMessage(ChatMessageType.ACTION_BAR, new TextComponent(message));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/utils/TaskManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/utils/TaskManager.java" />
              <option name="updatedContent" value="package loyfael.antiVillagerLag.utils;&#10;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.scheduler.BukkitRunnable;&#10;import org.bukkit.scheduler.BukkitTask;&#10;import loyfael.antiVillagerLag.AntiVillagerLag;&#10;&#10;import java.util.concurrent.CompletableFuture;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.ThreadFactory;&#10;import java.util.concurrent.atomic.AtomicInteger;&#10;&#10;/**&#10; * TaskManager optimisé pour 2000+ villagers&#10; * - Thread pool dédié pour éviter de bloquer le main thread&#10; * - Nettoyage automatique du cache&#10; * - Gestion de la mémoire optimisée&#10; */&#10;public class TaskManager {&#10;    &#10;    private static ExecutorService asyncExecutor;&#10;    private static BukkitTask cacheCleanupTask;&#10;    private static BukkitTask memoryOptimizationTask;&#10;    &#10;    // Thread factory personnalisé pour nommer les threads&#10;    private static final ThreadFactory THREAD_FACTORY = new ThreadFactory() {&#10;        private final AtomicInteger counter = new AtomicInteger(1);&#10;        &#10;        @Override&#10;        public Thread newThread(Runnable r) {&#10;            Thread thread = new Thread(r, &quot;AVL-Async-&quot; + counter.getAndIncrement());&#10;            thread.setDaemon(true);&#10;            thread.setPriority(Thread.NORM_PRIORITY - 1); // Légèrement moins prioritaire&#10;            return thread;&#10;        }&#10;    };&#10;    &#10;    public static void initialize(AntiVillagerLag plugin) {&#10;        // Thread pool optimisé pour les calculs villagers&#10;        int processors = Runtime.getRuntime().availableProcessors();&#10;        int poolSize = Math.max(2, Math.min(processors / 2, 4)); // 2-4 threads max&#10;        &#10;        asyncExecutor = Executors.newFixedThreadPool(poolSize, THREAD_FACTORY);&#10;        &#10;        // Nettoyage du cache toutes les 30 secondes (async)&#10;        cacheCleanupTask = new BukkitRunnable() {&#10;            @Override&#10;            public void run() {&#10;                CompletableFuture.runAsync(() -&gt; {&#10;                    VillagerCache.cleanupOldEntries();&#10;                    &#10;                    // Garbage collection suggéré si cache &gt; 1000 entrées&#10;                    if (VillagerCache.getCacheSize() &gt; 1000) {&#10;                        System.gc();&#10;                    }&#10;                }, asyncExecutor);&#10;            }&#10;        }.runTaskTimerAsynchronously(plugin, 600L, 600L); // 30s en ticks&#10;        &#10;        // Optimisation mémoire toutes les 5 minutes&#10;        memoryOptimizationTask = new BukkitRunnable() {&#10;            @Override&#10;            public void run() {&#10;                CompletableFuture.runAsync(() -&gt; {&#10;                    // Statistiques et optimisation&#10;                    long totalMemory = Runtime.getRuntime().totalMemory();&#10;                    long freeMemory = Runtime.getRuntime().freeMemory();&#10;                    long usedMemory = totalMemory - freeMemory;&#10;                    &#10;                    plugin.getLogger().info(String.format(&#10;                        &quot;AVL Memory: Used %d MB / %d MB | Cache: %d villagers&quot;,&#10;                        usedMemory / 1024 / 1024,&#10;                        totalMemory / 1024 / 1024,&#10;                        VillagerCache.getCacheSize()&#10;                    ));&#10;                    &#10;                    // Force cleanup si utilisation &gt; 80%&#10;                    if ((float) usedMemory / totalMemory &gt; 0.8f) {&#10;                        VillagerCache.clearCache();&#10;                        System.gc();&#10;                        plugin.getLogger().warning(&quot;AVL: Emergency memory cleanup performed&quot;);&#10;                    }&#10;                }, asyncExecutor);&#10;            }&#10;        }.runTaskTimerAsynchronously(plugin, 6000L, 6000L); // 5min en ticks&#10;    }&#10;    &#10;    public static void shutdown() {&#10;        if (cacheCleanupTask != null) {&#10;            cacheCleanupTask.cancel();&#10;        }&#10;        &#10;        if (memoryOptimizationTask != null) {&#10;            memoryOptimizationTask.cancel();&#10;        }&#10;        &#10;        if (asyncExecutor != null &amp;&amp; !asyncExecutor.isShutdown()) {&#10;            asyncExecutor.shutdown();&#10;        }&#10;    }&#10;    &#10;    // Exécution asynchrone avec retour sur le main thread si nécessaire&#10;    public static CompletableFuture&lt;Void&gt; runAsync(Runnable task) {&#10;        return CompletableFuture.runAsync(task, asyncExecutor);&#10;    }&#10;    &#10;    public static &lt;T&gt; CompletableFuture&lt;T&gt; supplyAsync(java.util.function.Supplier&lt;T&gt; supplier) {&#10;        return CompletableFuture.supplyAsync(supplier, asyncExecutor);&#10;    }&#10;    &#10;    // Synchronisation avec le main thread de Bukkit&#10;    public static void runSync(AntiVillagerLag plugin, Runnable task) {&#10;        if (Bukkit.isPrimaryThread()) {&#10;            task.run();&#10;        } else {&#10;            Bukkit.getScheduler().runTask(plugin, task);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/utils/VillagerCache.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/utils/VillagerCache.java" />
              <option name="updatedContent" value="package loyfael.antiVillagerLag.utils;&#10;&#10;import org.bukkit.entity.Villager;&#10;import loyfael.antiVillagerLag.AntiVillagerLag;&#10;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.UUID;&#10;&#10;/**&#10; * Cache haute performance pour éviter les accès répétés aux PersistentData&#10; * Optimisé pour gérer 2000+ villagers&#10; */&#10;public class VillagerCache {&#10;    &#10;    // Cache thread-safe pour les données des villagers&#10;    private static final ConcurrentHashMap&lt;UUID, VillagerData&gt; cache = new ConcurrentHashMap&lt;&gt;();&#10;    &#10;    // Classe interne pour stocker les données en mémoire&#10;    public static class VillagerData {&#10;        public boolean isMarked;&#10;        public boolean aiState;&#10;        public long aiCooldown;&#10;        public long levelCooldown;&#10;        public long lastRestock;&#10;        public long lastUpdate;&#10;        &#10;        public VillagerData(boolean isMarked, boolean aiState, long aiCooldown, long levelCooldown, long lastRestock) {&#10;            this.isMarked = isMarked;&#10;            this.aiState = aiState;&#10;            this.aiCooldown = aiCooldown;&#10;            this.levelCooldown = levelCooldown;&#10;            this.lastRestock = lastRestock;&#10;            this.lastUpdate = System.currentTimeMillis();&#10;        }&#10;    }&#10;    &#10;    public static VillagerData getVillagerData(Villager villager, AntiVillagerLag plugin) {&#10;        UUID uuid = villager.getUniqueId();&#10;        &#10;        // Vérifier le cache en premier&#10;        VillagerData cached = cache.get(uuid);&#10;        if (cached != null) {&#10;            return cached;&#10;        }&#10;        &#10;        // Si pas en cache, charger depuis PersistentData&#10;        boolean isMarked = VillagerUtilities.hasMarker(villager, plugin);&#10;        if (!isMarked) {&#10;            return null; // Villager pas encore configuré&#10;        }&#10;        &#10;        boolean aiState = VillagerUtilities.getMarker(villager, plugin);&#10;        long aiCooldown = VillagerUtilities.getAiCooldown(villager, plugin);&#10;        long levelCooldown = VillagerUtilities.getLevelCooldown(villager, plugin);&#10;        long lastRestock = VillagerUtilities.getLastRestock(villager, plugin);&#10;        &#10;        VillagerData data = new VillagerData(isMarked, aiState, aiCooldown, levelCooldown, lastRestock);&#10;        cache.put(uuid, data);&#10;        &#10;        return data;&#10;    }&#10;    &#10;    public static void updateVillagerData(Villager villager, VillagerData data) {&#10;        cache.put(villager.getUniqueId(), data);&#10;        data.lastUpdate = System.currentTimeMillis();&#10;    }&#10;    &#10;    public static void removeVillager(UUID uuid) {&#10;        cache.remove(uuid);&#10;    }&#10;    &#10;    public static void clearCache() {&#10;        cache.clear();&#10;    }&#10;    &#10;    // Nettoyage automatique des entrées anciennes (pour éviter les fuites mémoire)&#10;    public static void cleanupOldEntries() {&#10;        long now = System.currentTimeMillis();&#10;        long maxAge = 300000; // 5 minutes&#10;        &#10;        cache.entrySet().removeIf(entry -&gt; &#10;            (now - entry.getValue().lastUpdate) &gt; maxAge&#10;        );&#10;    }&#10;    &#10;    public static int getCacheSize() {&#10;        return cache.size();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/utils/VillagerUtilities.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/utils/VillagerUtilities.java" />
              <option name="originalContent" value="package loyfael.antiVillagerLag.utils;&#10;&#10;import org.bukkit.Material;&#10;import org.bukkit.NamespacedKey;&#10;import org.bukkit.entity.Villager;&#10;import org.bukkit.inventory.MerchantRecipe;&#10;import org.bukkit.persistence.PersistentDataContainer;&#10;import org.bukkit.persistence.PersistentDataType;&#10;import loyfael.antiVillagerLag.AntiVillagerLag;&#10;&#10;import java.util.ArrayList;&#10;import java.util.EnumSet;&#10;import java.util.List;&#10;import java.util.Set;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * VillagerUtilities optimisé pour 2000+ villagers&#10; * - Cache des NamespacedKeys&#10; * - Collections optimisées (Set vs List)&#10; * - Méthodes batch pour réduire les accès PersistentData&#10; */&#10;public class VillagerUtilities {&#10;&#10;    // Keys - Cached pour éviter les recréations&#10;    private static final String MARKER_KEY = &quot;Marker&quot;;&#10;    private static final String AI_COOLDOWN_KEY = &quot;cooldown&quot;;&#10;    private static final String LEVEL_COOLDOWN_KEY = &quot;levelCooldown&quot;;&#10;    private static final String LAST_RESTOCK_KEY = &quot;time&quot;;&#10;&#10;    // Cache des NamespacedKeys (thread-safe)&#10;    private static volatile NamespacedKey markerKey;&#10;    private static volatile NamespacedKey aiCooldownKey;&#10;    private static volatile NamespacedKey levelCooldownKey;&#10;    private static volatile NamespacedKey lastRestockKey;&#10;&#10;    public static final ColorCode colorcodes = new ColorCode();&#10;&#10;    // Collections optimisées pour les lookups rapides&#10;    public static final Set&lt;String&gt; disabling_names = ConcurrentHashMap.newKeySet();&#10;    public static final EnumSet&lt;Material&gt; standingon_blocks = EnumSet.noneOf(Material.class);&#10;    public static final EnumSet&lt;Material&gt; workstation_blocks = EnumSet.noneOf(Material.class);&#10;    public static final List&lt;Long&gt; restock_times = new ArrayList&lt;&gt;();&#10;&#10;    // Initialisation des clés (thread-safe)&#10;    public static synchronized void initializeKeys(AntiVillagerLag plugin) {&#10;        if (markerKey == null) {&#10;            markerKey = new NamespacedKey(plugin, MARKER_KEY);&#10;            aiCooldownKey = new NamespacedKey(plugin, AI_COOLDOWN_KEY);&#10;            levelCooldownKey = new NamespacedKey(plugin, LEVEL_COOLDOWN_KEY);&#10;            lastRestockKey = new NamespacedKey(plugin, LAST_RESTOCK_KEY);&#10;        }&#10;    }&#10;&#10;    // Méthode batch optimisée pour initialiser un nouveau villager&#10;    public static void initializeNewVillager(Villager villager, AntiVillagerLag plugin, long currentTime) {&#10;        PersistentDataContainer container = villager.getPersistentDataContainer();&#10;&#10;        // Batch write pour réduire les accès&#10;        container.set(markerKey, PersistentDataType.BOOLEAN, true);&#10;        container.set(aiCooldownKey, PersistentDataType.LONG, 0L);&#10;        container.set(levelCooldownKey, PersistentDataType.LONG, 0L);&#10;        container.set(lastRestockKey, PersistentDataType.LONG, villager.getWorld().getFullTime());&#10;    }&#10;&#10;    // Méthodes optimisées pour les accès fréquents&#10;    public static boolean hasMarker(Villager v, AntiVillagerLag plugin) {&#10;        return v.getPersistentDataContainer().has(markerKey, PersistentDataType.BOOLEAN);&#10;    }&#10;&#10;    public static boolean getMarker(Villager v, AntiVillagerLag plugin) {&#10;        Boolean result = v.getPersistentDataContainer().get(markerKey, PersistentDataType.BOOLEAN);&#10;        return result != null ? result : false;&#10;    }&#10;&#10;    public static void setMarker(Villager v, AntiVillagerLag plugin, boolean val) {&#10;        v.getPersistentDataContainer().set(markerKey, PersistentDataType.BOOLEAN, val);&#10;    }&#10;&#10;    // Getters optimisés avec valeurs par défaut&#10;    public static long getAiCooldown(Villager v, AntiVillagerLag plugin) {&#10;        Long result = v.getPersistentDataContainer().get(aiCooldownKey, PersistentDataType.LONG);&#10;        return result != null ? result : 0L;&#10;    }&#10;&#10;    public static long getLevelCooldown(Villager v, AntiVillagerLag plugin) {&#10;        Long result = v.getPersistentDataContainer().get(levelCooldownKey, PersistentDataType.LONG);&#10;        return result != null ? result : 0L;&#10;    }&#10;&#10;    public static long getLastRestock(Villager v, AntiVillagerLag plugin) {&#10;        Long result = v.getPersistentDataContainer().get(lastRestockKey, PersistentDataType.LONG);&#10;        return result != null ? result : 0L;&#10;    }&#10;&#10;    // Setters optimisés&#10;    public static void setAiCooldown(Villager v, AntiVillagerLag plugin, long cooldown) {&#10;        v.getPersistentDataContainer().set(aiCooldownKey, PersistentDataType.LONG,&#10;            (System.currentTimeMillis() / 1000) + cooldown);&#10;    }&#10;&#10;    public static void setLevelCooldown(Villager v, AntiVillagerLag plugin, long cooldown) {&#10;        v.getPersistentDataContainer().set(levelCooldownKey, PersistentDataType.LONG,&#10;            (System.currentTimeMillis() / 1000) + cooldown);&#10;    }&#10;&#10;    public static void setLastRestock(Villager v, AntiVillagerLag plugin) {&#10;        v.getPersistentDataContainer().set(lastRestockKey, PersistentDataType.LONG,&#10;            v.getWorld().getFullTime());&#10;    }&#10;&#10;    // Config loading optimisé avec clear+addAll pour éviter les fuites mémoire&#10;    public static void updateNameTags(AntiVillagerLag plugin) {&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.userenaming&quot;)) return;&#10;&#10;        disabling_names.clear();&#10;        List&lt;String&gt; names = plugin.getConfig().getStringList(&quot;NamesThatDisable&quot;);&#10;        for (String name : names) {&#10;            disabling_names.add(name.toLowerCase());&#10;        }&#10;    }&#10;&#10;    public static void updateStandingOnBlocks(AntiVillagerLag plugin) {&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.useblocks&quot;)) return;&#10;&#10;        standingon_blocks.clear();&#10;        List&lt;String&gt; blockNames = plugin.getConfig().getStringList(&quot;BlocksThatDisable&quot;);&#10;        for (String blockName : blockNames) {&#10;            Material block = Material.getMaterial(blockName.toUpperCase());&#10;            if (block != null) {&#10;                standingon_blocks.add(block);&#10;            }&#10;        }&#10;    }&#10;&#10;    public static void updateWorkstationBlocks(AntiVillagerLag plugin) {&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.useworkstations&quot;)) return;&#10;&#10;        workstation_blocks.clear();&#10;        List&lt;String&gt; blockNames = plugin.getConfig().getStringList(&quot;WorkstationsThatDisable&quot;);&#10;        for (String blockName : blockNames) {&#10;            Material block = Material.getMaterial(blockName.toUpperCase());&#10;            if (block != null) {&#10;                workstation_blocks.add(block);&#10;            }&#10;        }&#10;    }&#10;&#10;    public static void updateRestockTimes(AntiVillagerLag plugin) {&#10;        restock_times.clear();&#10;        restock_times.addAll(plugin.getConfig().getLongList(&quot;RestockTimes.times&quot;));&#10;    }&#10;&#10;    // Nettoyage optimisé&#10;    public static void CleanseTheVillagers(Villager v, AntiVillagerLag plugin) {&#10;        if (!hasMarker(v, plugin)) return;&#10;&#10;        v.setAware(true);&#10;        PersistentDataContainer container = v.getPersistentDataContainer();&#10;&#10;        // Batch removal&#10;        container.remove(markerKey);&#10;        container.remove(aiCooldownKey);&#10;        container.remove(levelCooldownKey);&#10;        container.remove(lastRestockKey);&#10;&#10;        // Nettoyer le cache aussi&#10;        VillagerCache.removeVillager(v.getUniqueId());&#10;    }&#10;&#10;    // Restock optimisé (éviter la création de nouvelle liste)&#10;    public static void restock(Villager v) {&#10;        List&lt;MerchantRecipe&gt; recipes = v.getRecipes();&#10;        for (int i = 0; i &lt; recipes.size(); i++) {&#10;            recipes.get(i).setUses(0);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package loyfael.antiVillagerLag.utils;&#10;&#10;import org.bukkit.Material;&#10;import org.bukkit.NamespacedKey;&#10;import org.bukkit.entity.Villager;&#10;import org.bukkit.inventory.MerchantRecipe;&#10;import org.bukkit.persistence.PersistentDataContainer;&#10;import org.bukkit.persistence.PersistentDataType;&#10;import loyfael.antiVillagerLag.AntiVillagerLag;&#10;&#10;import java.util.ArrayList;&#10;import java.util.EnumSet;&#10;import java.util.List;&#10;import java.util.Set;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * VillagerUtilities optimisé pour 2000+ villagers&#10; * - Cache des NamespacedKeys&#10; * - Collections optimisées (Set vs List)&#10; * - Méthodes batch pour réduire les accès PersistentData&#10; */&#10;public class VillagerUtilities {&#10;&#10;    // Keys - Cached pour éviter les recréations&#10;    private static final String MARKER_KEY = &quot;Marker&quot;;&#10;    private static final String AI_COOLDOWN_KEY = &quot;cooldown&quot;;&#10;    private static final String LEVEL_COOLDOWN_KEY = &quot;levelCooldown&quot;;&#10;    private static final String LAST_RESTOCK_KEY = &quot;time&quot;;&#10;&#10;    // Cache des NamespacedKeys (thread-safe)&#10;    private static volatile NamespacedKey markerKey;&#10;    private static volatile NamespacedKey aiCooldownKey;&#10;    private static volatile NamespacedKey levelCooldownKey;&#10;    private static volatile NamespacedKey lastRestockKey;&#10;&#10;    public static final ColorCode colorcodes = new ColorCode();&#10;&#10;    // Collections optimisées pour les lookups rapides&#10;    public static final Set&lt;String&gt; disabling_names = ConcurrentHashMap.newKeySet();&#10;    public static final EnumSet&lt;Material&gt; standingon_blocks = EnumSet.noneOf(Material.class);&#10;    public static final EnumSet&lt;Material&gt; workstation_blocks = EnumSet.noneOf(Material.class);&#10;    public static final List&lt;Long&gt; restock_times = new ArrayList&lt;&gt;();&#10;&#10;    // Initialisation des clés (thread-safe)&#10;    public static synchronized void initializeKeys(AntiVillagerLag plugin) {&#10;        if (markerKey == null) {&#10;            markerKey = new NamespacedKey(plugin, MARKER_KEY);&#10;            aiCooldownKey = new NamespacedKey(plugin, AI_COOLDOWN_KEY);&#10;            levelCooldownKey = new NamespacedKey(plugin, LEVEL_COOLDOWN_KEY);&#10;            lastRestockKey = new NamespacedKey(plugin, LAST_RESTOCK_KEY);&#10;        }&#10;    }&#10;&#10;    // Méthode batch optimisée pour initialiser un nouveau villager&#10;    public static void initializeNewVillager(Villager villager, AntiVillagerLag plugin, long currentTime) {&#10;        PersistentDataContainer container = villager.getPersistentDataContainer();&#10;&#10;        // Batch write pour réduire les accès&#10;        container.set(markerKey, PersistentDataType.BOOLEAN, true);&#10;        container.set(aiCooldownKey, PersistentDataType.LONG, 0L);&#10;        container.set(levelCooldownKey, PersistentDataType.LONG, 0L);&#10;        container.set(lastRestockKey, PersistentDataType.LONG, villager.getWorld().getFullTime());&#10;    }&#10;&#10;    // Méthodes optimisées pour les accès fréquents&#10;    public static boolean hasMarker(Villager v, AntiVillagerLag plugin) {&#10;        return v.getPersistentDataContainer().has(markerKey, PersistentDataType.BOOLEAN);&#10;    }&#10;&#10;    public static boolean getMarker(Villager v, AntiVillagerLag plugin) {&#10;        Boolean result = v.getPersistentDataContainer().get(markerKey, PersistentDataType.BOOLEAN);&#10;        return result != null ? result : false;&#10;    }&#10;&#10;    public static void setMarker(Villager v, AntiVillagerLag plugin, boolean val) {&#10;        v.getPersistentDataContainer().set(markerKey, PersistentDataType.BOOLEAN, val);&#10;    }&#10;&#10;    // Getters optimisés avec valeurs par défaut&#10;    public static long getAiCooldown(Villager v, AntiVillagerLag plugin) {&#10;        Long result = v.getPersistentDataContainer().get(aiCooldownKey, PersistentDataType.LONG);&#10;        return result != null ? result : 0L;&#10;    }&#10;&#10;    public static long getLevelCooldown(Villager v, AntiVillagerLag plugin) {&#10;        Long result = v.getPersistentDataContainer().get(levelCooldownKey, PersistentDataType.LONG);&#10;        return result != null ? result : 0L;&#10;    }&#10;&#10;    public static long getLastRestock(Villager v, AntiVillagerLag plugin) {&#10;        Long result = v.getPersistentDataContainer().get(lastRestockKey, PersistentDataType.LONG);&#10;        return result != null ? result : 0L;&#10;    }&#10;&#10;    // Setters optimisés&#10;    public static void setAiCooldown(Villager v, AntiVillagerLag plugin, long cooldown) {&#10;        v.getPersistentDataContainer().set(aiCooldownKey, PersistentDataType.LONG,&#10;            (System.currentTimeMillis() / 1000) + cooldown);&#10;    }&#10;&#10;    public static void setLevelCooldown(Villager v, AntiVillagerLag plugin, long cooldown) {&#10;        v.getPersistentDataContainer().set(levelCooldownKey, PersistentDataType.LONG,&#10;            (System.currentTimeMillis() / 1000) + cooldown);&#10;    }&#10;&#10;    public static void setLastRestock(Villager v, AntiVillagerLag plugin) {&#10;        v.getPersistentDataContainer().set(lastRestockKey, PersistentDataType.LONG,&#10;            v.getWorld().getFullTime());&#10;    }&#10;&#10;    // Config loading optimisé avec clear+addAll pour éviter les fuites mémoire&#10;    public static void updateNameTags(AntiVillagerLag plugin) {&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.userenaming&quot;)) return;&#10;&#10;        disabling_names.clear();&#10;        List&lt;String&gt; names = plugin.getConfig().getStringList(&quot;NamesThatDisable&quot;);&#10;        for (String name : names) {&#10;            disabling_names.add(name.toLowerCase());&#10;        }&#10;    }&#10;&#10;    public static void updateStandingOnBlocks(AntiVillagerLag plugin) {&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.useblocks&quot;)) return;&#10;&#10;        standingon_blocks.clear();&#10;        List&lt;String&gt; blockNames = plugin.getConfig().getStringList(&quot;BlocksThatDisable&quot;);&#10;        for (String blockName : blockNames) {&#10;            Material block = Material.getMaterial(blockName.toUpperCase());&#10;            if (block != null) {&#10;                standingon_blocks.add(block);&#10;            }&#10;        }&#10;    }&#10;&#10;    public static void updateWorkstationBlocks(AntiVillagerLag plugin) {&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.useworkstations&quot;)) return;&#10;&#10;        workstation_blocks.clear();&#10;        List&lt;String&gt; blockNames = plugin.getConfig().getStringList(&quot;WorkstationsThatDisable&quot;);&#10;        for (String blockName : blockNames) {&#10;            Material block = Material.getMaterial(blockName.toUpperCase());&#10;            if (block != null) {&#10;                workstation_blocks.add(block);&#10;            }&#10;        }&#10;    }&#10;&#10;    public static void updateRestockTimes(AntiVillagerLag plugin) {&#10;        restock_times.clear();&#10;        restock_times.addAll(plugin.getConfig().getLongList(&quot;RestockTimes.times&quot;));&#10;    }&#10;&#10;    // Nettoyage optimisé&#10;    public static void CleanseTheVillagers(Villager v, AntiVillagerLag plugin) {&#10;        if (!hasMarker(v, plugin)) return;&#10;&#10;        v.setAware(true);&#10;        PersistentDataContainer container = v.getPersistentDataContainer();&#10;&#10;        // Batch removal&#10;        container.remove(markerKey);&#10;        container.remove(aiCooldownKey);&#10;        container.remove(levelCooldownKey);&#10;        container.remove(lastRestockKey);&#10;&#10;        // Nettoyer le cache aussi&#10;        VillagerCache.removeVillager(v.getUniqueId());&#10;    }&#10;&#10;    // Restock optimisé (éviter la création de nouvelle liste)&#10;    public static void restock(Villager v) {&#10;        List&lt;MerchantRecipe&gt; recipes = v.getRecipes();&#10;        for (int i = 0; i &lt; recipes.size(); i++) {&#10;            recipes.get(i).setUses(0);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/AntiVillagerLag.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/AntiVillagerLag.java" />
              <option name="originalContent" value="package rebelmythik.antiVillagerLag;&#10;&#10;import org.bstats.bukkit.Metrics;&#10;import org.bstats.charts.MultiLineChart;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.ChatColor;&#10;import org.bukkit.configuration.Configuration;&#10;import org.bukkit.configuration.InvalidConfigurationException;&#10;import org.bukkit.configuration.file.YamlConfiguration;&#10;import org.bukkit.plugin.java.JavaPlugin;&#10;import rebelmythik.antiVillagerLag.commands.OptimizeCommand;&#10;import rebelmythik.antiVillagerLag.commands.ReloadCommand;&#10;import rebelmythik.antiVillagerLag.commands.RemoveChangesCommand;&#10;import rebelmythik.antiVillagerLag.commands.UnoptimizeCommand;&#10;import rebelmythik.antiVillagerLag.events.EventListener;&#10;import rebelmythik.antiVillagerLag.utils.UpdateChecker;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;import java.io.File;&#10;import java.io.IOException;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public final class AntiVillagerLag extends JavaPlugin {&#10;&#10;    @Override&#10;    public void onEnable() {&#10;&#10;        //  Command Registration&#10;        getCommand(&quot;avlreload&quot;).setExecutor(new ReloadCommand(this));&#10;        getCommand(&quot;avloptimize&quot;).setExecutor(new OptimizeCommand(this));&#10;        getCommand(&quot;avlunoptimize&quot;).setExecutor(new UnoptimizeCommand(this));&#10;        getCommand(&quot;avlremove&quot;).setExecutor(new RemoveChangesCommand(this));&#10;&#10;        //  Event Registration&#10;        getServer().getPluginManager().registerEvents(new EventListener(this), this);&#10;&#10;&#10;        //  Config Stuff&#10;        saveDefaultConfig();&#10;        updateConfig();&#10;&#10;        VillagerUtilities.updateNameTags(this);&#10;        VillagerUtilities.updateStandingOnBlocks(this);&#10;        VillagerUtilities.updateWorkstationBlocks(this);&#10;        VillagerUtilities.updateRestockTimes(this);&#10;&#10;        //  Bstats Code&#10;        int pluginId = 15890;&#10;        Metrics metrics = new Metrics(this, pluginId);&#10;        //  Optional: Add custom charts&#10;        metrics.addCustomChart(new MultiLineChart(&quot;players_and_servers&quot;, () -&gt; {&#10;            Map&lt;String, Integer&gt; valueMap = new HashMap&lt;&gt;();&#10;            valueMap.put(&quot;servers&quot;, 1);&#10;            valueMap.put(&quot;players&quot;, Bukkit.getOnlinePlayers().size());&#10;            return valueMap;&#10;        }));&#10;&#10;        //  Check for plugin updates&#10;        new UpdateChecker(this, 102949).getVersion(version -&gt; {&#10;            if (this.getDescription().getVersion().equals(version)) {&#10;                getLogger().info(&quot;AntiVillagerLag is up to date!&quot;);&#10;            } else {&#10;                getLogger().info(&quot;There is an update for AntiVillagerLag! https://www.spigotmc.org/resources/antivillagerlag.102949/&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void onDisable() {&#10;        //  Plugin shutdown logic&#10;    }&#10;&#10;    //  Configuration File Updater&#10;    public Configuration cfg = this.getConfig().getDefaults();&#10;    public void updateConfig() {&#10;        try {&#10;            if(new File(getDataFolder() + &quot;/config.yml&quot;).exists()) {&#10;                boolean changesMade = false;&#10;                YamlConfiguration tmp = new YamlConfiguration();&#10;                tmp.load(getDataFolder() + &quot;/config.yml&quot;);&#10;                for(String str : cfg.getKeys(true)) {&#10;                    if(!tmp.getKeys(true).contains(str)) {&#10;                        tmp.set(str, cfg.get(str));&#10;                        changesMade = true;&#10;                    }&#10;                }&#10;                if(changesMade)&#10;                    tmp.save(getDataFolder() + &quot;/config.yml&quot;);&#10;            }&#10;        } catch (IOException | InvalidConfigurationException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag;&#10;&#10;import org.bstats.bukkit.Metrics;&#10;import org.bstats.charts.MultiLineChart;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.ChatColor;&#10;import org.bukkit.configuration.Configuration;&#10;import org.bukkit.configuration.InvalidConfigurationException;&#10;import org.bukkit.configuration.file.YamlConfiguration;&#10;import org.bukkit.plugin.java.JavaPlugin;&#10;import rebelmythik.antiVillagerLag.commands.OptimizeCommand;&#10;import rebelmythik.antiVillagerLag.commands.ReloadCommand;&#10;import rebelmythik.antiVillagerLag.commands.RemoveChangesCommand;&#10;import rebelmythik.antiVillagerLag.commands.UnoptimizeCommand;&#10;import rebelmythik.antiVillagerLag.commands.StatusCommand;&#10;import rebelmythik.antiVillagerLag.events.EventListener;&#10;import rebelmythik.antiVillagerLag.utils.UpdateChecker;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;import java.io.File;&#10;import java.io.IOException;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public final class AntiVillagerLag extends JavaPlugin {&#10;&#10;    @Override&#10;    public void onEnable() {&#10;&#10;        //  Command Registration&#10;        getCommand(&quot;avlreload&quot;).setExecutor(new ReloadCommand(this));&#10;        getCommand(&quot;avloptimize&quot;).setExecutor(new OptimizeCommand(this));&#10;        getCommand(&quot;avlunoptimize&quot;).setExecutor(new UnoptimizeCommand(this));&#10;        getCommand(&quot;avlremove&quot;).setExecutor(new RemoveChangesCommand(this));&#10;        getCommand(&quot;avlstatus&quot;).setExecutor(new StatusCommand(this));&#10;&#10;        //  Event Registration&#10;        getServer().getPluginManager().registerEvents(new EventListener(this), this);&#10;&#10;&#10;        //  Config Stuff&#10;        saveDefaultConfig();&#10;        updateConfig();&#10;&#10;        VillagerUtilities.updateNameTags(this);&#10;        VillagerUtilities.updateStandingOnBlocks(this);&#10;        VillagerUtilities.updateWorkstationBlocks(this);&#10;        VillagerUtilities.updateRestockTimes(this);&#10;&#10;        //  Bstats Code&#10;        int pluginId = 15890;&#10;        Metrics metrics = new Metrics(this, pluginId);&#10;        //  Optional: Add custom charts&#10;        metrics.addCustomChart(new MultiLineChart(&quot;players_and_servers&quot;, () -&gt; {&#10;            Map&lt;String, Integer&gt; valueMap = new HashMap&lt;&gt;();&#10;            valueMap.put(&quot;servers&quot;, 1);&#10;            valueMap.put(&quot;players&quot;, Bukkit.getOnlinePlayers().size());&#10;            return valueMap;&#10;        }));&#10;&#10;        //  Check for plugin updates&#10;        new UpdateChecker(this, 102949).getVersion(version -&gt; {&#10;            if (this.getDescription().getVersion().equals(version)) {&#10;                getLogger().info(&quot;AntiVillagerLag is up to date!&quot;);&#10;            } else {&#10;                getLogger().info(&quot;There is an update for AntiVillagerLag! https://www.spigotmc.org/resources/antivillagerlag.102949/&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void onDisable() {&#10;        //  Plugin shutdown logic&#10;    }&#10;&#10;    //  Configuration File Updater&#10;    public Configuration cfg = this.getConfig().getDefaults();&#10;    public void updateConfig() {&#10;        try {&#10;            if(new File(getDataFolder() + &quot;/config.yml&quot;).exists()) {&#10;                boolean changesMade = false;&#10;                YamlConfiguration tmp = new YamlConfiguration();&#10;                tmp.load(getDataFolder() + &quot;/config.yml&quot;);&#10;                for(String str : cfg.getKeys(true)) {&#10;                    if(!tmp.getKeys(true).contains(str)) {&#10;                        tmp.set(str, cfg.get(str));&#10;                        changesMade = true;&#10;                    }&#10;                }&#10;                if(changesMade)&#10;                    tmp.save(getDataFolder() + &quot;/config.yml&quot;);&#10;            }&#10;        } catch (IOException | InvalidConfigurationException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/commands/OptimizeCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/commands/OptimizeCommand.java" />
              <option name="originalContent" value="package rebelmythik.antiVillagerLag.commands;&#10;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.entity.Entity;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.events.BlockAI;&#10;import rebelmythik.antiVillagerLag.events.NameTagAI;&#10;import rebelmythik.antiVillagerLag.events.WorkblockAI;&#10;import rebelmythik.antiVillagerLag.utils.ColorCode;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class OptimizeCommand implements CommandExecutor {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;    public OptimizeCommand(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender commandSender, Command command, String s, String[] strings) {&#10;        if (!command.getName().equalsIgnoreCase(&quot;avloptimize&quot;)) return true;&#10;        //  Make sure it's a player&#10;        if (!(commandSender instanceof Player)) return false;&#10;        Player player = (Player) commandSender;&#10;&#10;        //  Check if they have permission&#10;        if(!player.hasPermission(&quot;avl.optimize&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.no-permission&quot;)));&#10;            return true;&#10;        }&#10;&#10;        //searchable radius based on first argument specified, if null defaults to config&#10;        int radius;&#10;        try{&#10;            radius = (strings != null &amp;&amp; strings.length &gt; 0) ? Integer.parseInt(strings[0]) : plugin.getConfig().getInt(&quot;RadiusDefault&quot;);&#10;        } catch (NumberFormatException e) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-invalid&quot;)));&#10;            return true;&#10;        }&#10;        boolean canSearchRadius = radius &lt;= plugin.getConfig().getInt(&quot;RadiusLimit&quot;);&#10;        if(!canSearchRadius){&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-limit&quot;)).replace(&quot;%avlradiuslimit%&quot;, plugin.getConfig().getString(&quot;RadiusLimit&quot;)));&#10;            return true;&#10;        }&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.searching-radius&quot;)).replace(&quot;%avlradius%&quot;, String.valueOf(radius)));&#10;&#10;        // Search for nearby villagers&#10;        player.getNearbyEntities(radius, radius, radius).forEach(entity -&gt; {&#10;            if (entity instanceof Villager) {&#10;                Villager villager = (Villager) entity;&#10;                //  Setup new Villagers&#10;                if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;                    VillagerUtilities.setAiCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLevelCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLastRestock(villager, plugin);&#10;                    VillagerUtilities.setMarker(villager, plugin, true);&#10;                }&#10;                //  Rename villager&#10;                villager.setCustomName(VillagerUtilities.disabling_names.getFirst());&#10;                //  Update the marker and AI&#10;                VillagerUtilities.setMarker(villager, plugin, false);&#10;                villager.setAware(false);&#10;&#10;            }&#10;        });&#10;        return true;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag.commands;&#10;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.entity.Entity;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.events.BlockAI;&#10;import rebelmythik.antiVillagerLag.events.NameTagAI;&#10;import rebelmythik.antiVillagerLag.events.WorkblockAI;&#10;import rebelmythik.antiVillagerLag.utils.ColorCode;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class OptimizeCommand implements CommandExecutor {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;    public OptimizeCommand(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender commandSender, Command command, String s, String[] strings) {&#10;        if (!command.getName().equalsIgnoreCase(&quot;avloptimize&quot;)) return true;&#10;        //  Make sure it's a player&#10;        if (!(commandSender instanceof Player)) return false;&#10;        Player player = (Player) commandSender;&#10;&#10;        //  Check if they have permission&#10;        if(!player.hasPermission(&quot;avl.optimize&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.no-permission&quot;)));&#10;            return true;&#10;        }&#10;&#10;        //searchable radius based on first argument specified, if null defaults to config&#10;        int radius;&#10;        try{&#10;            radius = (strings != null &amp;&amp; strings.length &gt; 0) ? Integer.parseInt(strings[0]) : plugin.getConfig().getInt(&quot;RadiusDefault&quot;);&#10;        } catch (NumberFormatException e) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-invalid&quot;)));&#10;            return true;&#10;        }&#10;        boolean canSearchRadius = radius &lt;= plugin.getConfig().getInt(&quot;RadiusLimit&quot;);&#10;        if(!canSearchRadius){&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-limit&quot;)).replace(&quot;%avlradiuslimit%&quot;, plugin.getConfig().getString(&quot;RadiusLimit&quot;)));&#10;            return true;&#10;        }&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.searching-radius&quot;)).replace(&quot;%avlradius%&quot;, String.valueOf(radius)));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.bulk-optimize-start&quot;)));&#10;&#10;        // Counter for optimized villagers&#10;        int optimizedCount = 0;&#10;&#10;        // Search for nearby villagers&#10;        for (Entity entity : player.getNearbyEntities(radius, radius, radius)) {&#10;            if (entity instanceof Villager) {&#10;                Villager villager = (Villager) entity;&#10;                //  Setup new Villagers&#10;                if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;                    VillagerUtilities.setAiCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLevelCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLastRestock(villager, plugin);&#10;                    VillagerUtilities.setMarker(villager, plugin, true);&#10;                }&#10;                &#10;                // Only optimize if not already optimized&#10;                if (VillagerUtilities.getMarker(villager, plugin)) {&#10;                    //  Rename villager&#10;                    villager.setCustomName(VillagerUtilities.disabling_names.getFirst());&#10;                    //  Update the marker and AI&#10;                    VillagerUtilities.setMarker(villager, plugin, false);&#10;                    villager.setAware(false);&#10;                    optimizedCount++;&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Send completion message with statistics&#10;        String completeMsg = plugin.getConfig().getString(&quot;messages.bulk-optimize-complete&quot;);&#10;        completeMsg = completeMsg.replace(&quot;%avlcount%&quot;, String.valueOf(optimizedCount));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(completeMsg));&#10;        &#10;        // Calculate and show performance impact&#10;        if (optimizedCount &gt; 0) {&#10;            int estimatedPerformanceGain = Math.min(90, optimizedCount * 2); // Rough estimate: 2% per villager, max 90%&#10;            String performanceMsg = plugin.getConfig().getString(&quot;messages.performance-impact&quot;);&#10;            performanceMsg = performanceMsg.replace(&quot;%avlpercentage%&quot;, String.valueOf(estimatedPerformanceGain));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(performanceMsg));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-zombie-protected&quot;)));&#10;        }&#10;        return true;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/commands/StatusCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/commands/StatusCommand.java" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag.commands;&#10;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.entity.Entity;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class StatusCommand implements CommandExecutor {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;    public StatusCommand(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender commandSender, Command command, String s, String[] strings) {&#10;        if (!command.getName().equalsIgnoreCase(&quot;avlstatus&quot;)) return true;&#10;        &#10;        // Make sure it's a player&#10;        if (!(commandSender instanceof Player)) return false;&#10;        Player player = (Player) commandSender;&#10;&#10;        // Check if they have permission&#10;        if(!player.hasPermission(&quot;avl.status&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.no-permission&quot;)));&#10;            return true;&#10;        }&#10;&#10;        // Default radius or specified radius&#10;        int radius;&#10;        try{&#10;            radius = (strings != null &amp;&amp; strings.length &gt; 0) ? Integer.parseInt(strings[0]) : plugin.getConfig().getInt(&quot;RadiusDefault&quot;);&#10;        } catch (NumberFormatException e) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-invalid&quot;)));&#10;            return true;&#10;        }&#10;&#10;        boolean canSearchRadius = radius &lt;= plugin.getConfig().getInt(&quot;RadiusLimit&quot;);&#10;        if(!canSearchRadius){&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-limit&quot;)).replace(&quot;%avlradiuslimit%&quot;, plugin.getConfig().getString(&quot;RadiusLimit&quot;)));&#10;            return true;&#10;        }&#10;&#10;        // Count villagers&#10;        int totalVillagers = 0;&#10;        int optimizedVillagers = 0;&#10;        int activeVillagers = 0;&#10;        int unmanagedVillagers = 0;&#10;&#10;        // Search for nearby villagers&#10;        for (Entity entity : player.getNearbyEntities(radius, radius, radius)) {&#10;            if (entity instanceof Villager) {&#10;                Villager villager = (Villager) entity;&#10;                totalVillagers++;&#10;&#10;                if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;                    unmanagedVillagers++;&#10;                } else if (!VillagerUtilities.getMarker(villager, plugin)) {&#10;                    optimizedVillagers++;&#10;                } else {&#10;                    activeVillagers++;&#10;                }&#10;            }&#10;        }&#10;&#10;        // Send status report&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;6━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;6            AntiVillagerLag Status Report&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;6━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;e Search Radius: &amp;7&quot; + radius + &quot; blocks&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;f Total Villagers Found: &amp;b&quot; + totalVillagers));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;a✅ Optimized (Frozen): &amp;2&quot; + optimizedVillagers));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;e⚡ Active (Mobile): &amp;6&quot; + activeVillagers));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;7❓ Unmanaged: &amp;8&quot; + unmanagedVillagers));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&quot;));&#10;        &#10;        if (totalVillagers &gt; 0) {&#10;            int optimizationRate = (optimizedVillagers * 100) / totalVillagers;&#10;            int estimatedPerformanceGain = Math.min(90, optimizedVillagers * 2);&#10;            &#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;f Optimization Rate: &amp;b&quot; + optimizationRate + &quot;%&quot;));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;f Estimated Performance Gain: &amp;a~&quot; + estimatedPerformanceGain + &quot;%&quot;));&#10;            &#10;            if (optimizationRate &lt; 70) {&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;c⚠ Consider optimizing more villagers for better performance!&quot;));&#10;            } else if (optimizationRate &gt;= 70 &amp;&amp; optimizationRate &lt; 90) {&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;e Good optimization level!&quot;));&#10;            } else {&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;a Excellent optimization! Great job!&quot;));&#10;            }&#10;        }&#10;        &#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;7 Use &amp;f/avloptimize &quot; + radius + &quot;&amp;7 to optimize all villagers&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;6━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&quot;));&#10;&#10;        return true;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/commands/UnoptimizeCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/commands/UnoptimizeCommand.java" />
              <option name="originalContent" value="package rebelmythik.antiVillagerLag.commands;&#10;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class UnoptimizeCommand implements CommandExecutor {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;    public UnoptimizeCommand(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender commandSender, Command command, String s, String[] strings) {&#10;        if (!command.getName().equalsIgnoreCase(&quot;avlunoptimize&quot;)) return true;&#10;        //  Make sure it's a player&#10;        if (!(commandSender instanceof Player)) return false;&#10;        Player player = (Player) commandSender;&#10;&#10;        //  Check if they have permission&#10;        if(!player.hasPermission(&quot;avl.unoptimize&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.no-permission&quot;)));&#10;            return true;&#10;        }&#10;&#10;        //searchable radius based on first argument specified, if null defaults to config&#10;        int radius;&#10;        try{&#10;            radius = (strings != null &amp;&amp; strings.length &gt; 0) ? Integer.parseInt(strings[0]) : plugin.getConfig().getInt(&quot;RadiusDefault&quot;);&#10;        } catch (NumberFormatException e) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-invalid&quot;)));&#10;            return true;&#10;        }&#10;        boolean canSearchRadius = radius &lt;= plugin.getConfig().getInt(&quot;RadiusLimit&quot;);&#10;        if(!canSearchRadius){&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-limit&quot;)).replace(&quot;%avlradiuslimit%&quot;, plugin.getConfig().getString(&quot;RadiusLimit&quot;)));&#10;            return true;&#10;        }&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.searching-radius&quot;)).replace(&quot;%avlradius%&quot;, String.valueOf(radius)));&#10;&#10;        // Search for nearby villagers&#10;        player.getNearbyEntities(radius, radius, radius).forEach(entity -&gt; {&#10;            if (entity instanceof Villager) {&#10;                Villager villager = (Villager) entity;&#10;                //  Setup new Villagers&#10;                if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;                    VillagerUtilities.setAiCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLevelCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLastRestock(villager, plugin);&#10;                    VillagerUtilities.setMarker(villager, plugin, true);&#10;                }&#10;                //  Rename villager&#10;                villager.setCustomName(&quot;&quot;);&#10;                //  Update the marker and AI&#10;                VillagerUtilities.setMarker(villager, plugin, true);&#10;                villager.setAware(true);&#10;            }&#10;        });&#10;        return true;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag.commands;&#10;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class UnoptimizeCommand implements CommandExecutor {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;    public UnoptimizeCommand(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender commandSender, Command command, String s, String[] strings) {&#10;        if (!command.getName().equalsIgnoreCase(&quot;avlunoptimize&quot;)) return true;&#10;        //  Make sure it's a player&#10;        if (!(commandSender instanceof Player)) return false;&#10;        Player player = (Player) commandSender;&#10;&#10;        //  Check if they have permission&#10;        if(!player.hasPermission(&quot;avl.unoptimize&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.no-permission&quot;)));&#10;            return true;&#10;        }&#10;&#10;        //searchable radius based on first argument specified, if null defaults to config&#10;        int radius;&#10;        try{&#10;            radius = (strings != null &amp;&amp; strings.length &gt; 0) ? Integer.parseInt(strings[0]) : plugin.getConfig().getInt(&quot;RadiusDefault&quot;);&#10;        } catch (NumberFormatException e) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-invalid&quot;)));&#10;            return true;&#10;        }&#10;        boolean canSearchRadius = radius &lt;= plugin.getConfig().getInt(&quot;RadiusLimit&quot;);&#10;        if(!canSearchRadius){&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-limit&quot;)).replace(&quot;%avlradiuslimit%&quot;, plugin.getConfig().getString(&quot;RadiusLimit&quot;)));&#10;            return true;&#10;        }&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.searching-radius&quot;)).replace(&quot;%avlradius%&quot;, String.valueOf(radius)));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.bulk-unoptimize-start&quot;)));&#10;&#10;        // Counter for unoptimized villagers&#10;        int unoptimizedCount = 0;&#10;&#10;        // Search for nearby villagers&#10;        for (org.bukkit.entity.Entity entity : player.getNearbyEntities(radius, radius, radius)) {&#10;            if (entity instanceof Villager) {&#10;                Villager villager = (Villager) entity;&#10;                //  Setup new Villagers&#10;                if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;                    VillagerUtilities.setAiCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLevelCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLastRestock(villager, plugin);&#10;                    VillagerUtilities.setMarker(villager, plugin, true);&#10;                }&#10;                &#10;                // Only unoptimize if currently optimized&#10;                if (!VillagerUtilities.getMarker(villager, plugin)) {&#10;                    //  Rename villager&#10;                    villager.setCustomName(&quot;&quot;);&#10;                    //  Update the marker and AI&#10;                    VillagerUtilities.setMarker(villager, plugin, true);&#10;                    villager.setAware(true);&#10;                    unoptimizedCount++;&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Send completion message with statistics&#10;        String completeMsg = plugin.getConfig().getString(&quot;messages.bulk-unoptimize-complete&quot;);&#10;        completeMsg = completeMsg.replace(&quot;%avlcount%&quot;, String.valueOf(unoptimizedCount));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(completeMsg));&#10;        &#10;        // Show breeding reminder if villagers were activated&#10;        if (unoptimizedCount &gt; 0) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-breeding-reminder&quot;)));&#10;        }&#10;        return true;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/events/EventListener.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/events/EventListener.java" />
              <option name="originalContent" value="package rebelmythik.antiVillagerLag.events;&#10;&#10;import org.bukkit.ChatColor;&#10;import org.bukkit.Material;&#10;import org.bukkit.entity.*;&#10;import org.bukkit.event.Listener;&#10;import org.bukkit.event.EventHandler;&#10;import org.bukkit.event.entity.EntityDamageByEntityEvent;&#10;import org.bukkit.event.inventory.InventoryClickEvent;&#10;import org.bukkit.event.inventory.InventoryCloseEvent;&#10;import org.bukkit.event.inventory.InventoryType;&#10;import org.bukkit.event.inventory.TradeSelectEvent;&#10;import org.bukkit.event.player.PlayerInteractEntityEvent;&#10;import org.bukkit.event.player.PlayerJoinEvent;&#10;import org.bukkit.inventory.ItemStack;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.UpdateChecker;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class EventListener implements Listener {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;&#10;    public EventListener(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;&#10;    @EventHandler&#10;    public void onRightClick(PlayerInteractEntityEvent event) {&#10;        if (event.isCancelled()) return;&#10;        Player player = event.getPlayer();&#10;        //  It's a villager&#10;        if (!event.getRightClicked().getType().equals(EntityType.VILLAGER)) return;&#10;        Villager villager = (Villager) event.getRightClicked();&#10;&#10;        //  Setup new Villagers&#10;        if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;            VillagerUtilities.setAiCooldown(villager, plugin, 0L);&#10;            VillagerUtilities.setLevelCooldown(villager, plugin, 0L);&#10;            VillagerUtilities.setLastRestock(villager, plugin);&#10;            VillagerUtilities.setMarker(villager, plugin, true);&#10;        }&#10;&#10;        //  Get Times&#10;        long currentTime = System.currentTimeMillis() / 1000;&#10;        long vilLevelCooldown = VillagerUtilities.getLevelCooldown(villager, plugin);&#10;        long vilAiCooldown = VillagerUtilities.getAiCooldown(villager, plugin);&#10;        long totalSeconds = vilAiCooldown - currentTime;&#10;        long sec = totalSeconds % 60;&#10;        long min = totalSeconds / 60;&#10;&#10;        //  If the villager is leveling up&#10;        if (vilLevelCooldown &gt; currentTime) {&#10;            String message = plugin.getConfig().getString(&quot;messages.cooldown-levelup-message&quot;);&#10;            long level_sec = vilLevelCooldown - currentTime;&#10;            message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(level_sec));&#10;            event.getPlayer().sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;            villager.shakeHead();&#10;            event.setCancelled(true);&#10;            return;&#10;        }&#10;&#10;        //  Should it be disabled?&#10;        boolean nametag_result = NameTagAI.call(villager, plugin, player);&#10;        boolean block_result = BlockAI.call(villager, plugin, player);&#10;        boolean workblock_result = WorkblockAI.call(villager, plugin, player);&#10;        boolean should_be_disabled = nametag_result || block_result || workblock_result;&#10;&#10;&#10;        //  If villager AI is being toggled&#10;        if (should_be_disabled == VillagerUtilities.getMarker(villager, plugin)) {&#10;            //  If toggling is on cooldown&#10;            if ((vilAiCooldown &gt; currentTime) &amp;&amp; !player.hasPermission(&quot;avl.cooldown.bypass&quot;)) {&#10;                //Tell player it's on cooldown&#10;                String message = plugin.getConfig().getString(&quot;messages.cooldown-ai-message&quot;);&#10;                message = message.replaceAll(&quot;%avlminutes%&quot;, Long.toString(min));&#10;                message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(sec));&#10;                event.getPlayer().sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;                event.setCancelled(true);&#10;            //  If cooldown is over&#10;            } else {&#10;                VillagerUtilities.setMarker(villager, plugin, !should_be_disabled);&#10;                villager.setAware(!should_be_disabled);&#10;                VillagerUtilities.setAiCooldown(villager, plugin, plugin.getConfig().getLong(&quot;ai-toggle-cooldown&quot;));&#10;                //  If nametag shouldn't be consumed, give one back&#10;                if (player.getInventory().getItemInMainHand().getType().equals(Material.NAME_TAG) &amp;&amp; !plugin.getConfig().getBoolean(&quot;toggleableoptions.usenametags&quot;)) {&#10;                    ItemStack nametag = player.getInventory().getItemInMainHand();&#10;                    if (!nametag.getItemMeta().hasDisplayName()) return;&#10;                    player.getInventory().getItemInMainHand().setAmount(player.getInventory().getItemInMainHand().getAmount() + 1);&#10;                }&#10;            }&#10;        }&#10;        //  If the villager AI is not being toggled&#10;        else {&#10;            //  If nametag shouldn't be consumed, give one back&#10;            if (!VillagerUtilities.hasMarker(villager, plugin)) return;&#10;            if (player.getInventory().getItemInMainHand().getType().equals(Material.NAME_TAG) &amp;&amp; !plugin.getConfig().getBoolean(&quot;toggleableoptions.usenametags&quot;)) {&#10;                ItemStack nametag = player.getInventory().getItemInMainHand();&#10;                if (!nametag.getItemMeta().hasDisplayName()) return;&#10;                player.getInventory().getItemInMainHand().setAmount(player.getInventory().getItemInMainHand().getAmount() + 1);&#10;            }&#10;        }&#10;&#10;        //  Restock&#10;        if (!VillagerUtilities.getMarker(villager, plugin)) {&#10;            RestockVillager.call(villager, plugin, player);&#10;        }&#10;    }&#10;&#10;    // Code for forcing players to disable villagers&#10;&#10;    @EventHandler&#10;    public void inventoryMove(InventoryClickEvent event) {&#10;        if (event.isCancelled()) return;&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.preventtrading&quot;)) return;&#10;        if (!(event.getInventory().getHolder() instanceof Villager)) return;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (!VillagerUtilities.getMarker(vil, plugin)) return;&#10;        Player player = (Player) event.getWhoClicked();&#10;        event.setCancelled(true);&#10;        //player.closeInventory();&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.VillagerMustBeDisabled&quot;)));&#10;    }&#10;&#10;    @EventHandler&#10;    public void villagerTradeClick(TradeSelectEvent event) {&#10;        if (event.isCancelled()) return;&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.preventtrading&quot;)) return;&#10;        if (!(event.getInventory().getHolder() instanceof Villager)) return;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (!VillagerUtilities.getMarker(vil, plugin)) return;&#10;        Player player = (Player) event.getWhoClicked();&#10;        event.setCancelled(true);&#10;        player.closeInventory();&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.VillagerMustBeDisabled&quot;)));&#10;    }&#10;&#10;    // Event to handle cancellation of damage to villagers disable by the plugin&#10;    @EventHandler&#10;    public void onCancelVillagerDamage(EntityDamageByEntityEvent event) {&#10;        if (event.isCancelled()) return;&#10;        if (!(event.getEntity() instanceof Villager &amp;&amp; event.getDamager() instanceof Zombie)) return;&#10;&#10;        Villager vil = (Villager) event.getEntity();&#10;&#10;        if (VillagerUtilities.hasMarker(vil, plugin) &amp;&amp; !VillagerUtilities.getMarker(vil, plugin)) {&#10;            event.setCancelled(true);&#10;        }&#10;    }&#10;&#10;    @EventHandler&#10;    public void playerJoin(PlayerJoinEvent event) {&#10;        if (!event.getPlayer().hasPermission(&quot;avl.notify.update&quot;)) return;&#10;        new UpdateChecker(plugin, 102949).getVersion(version -&gt; {&#10;            if (plugin.getDescription().getVersion().equals(version)) {&#10;                event.getPlayer().sendMessage(ChatColor.GREEN + &quot;AntiVillagerLag is up to date!&quot;);&#10;            } else {&#10;                event.getPlayer().sendMessage(ChatColor.GREEN + &quot;There is an update for AntiVillagerLag! https://www.spigotmc.org/resources/antivillagerlag.102949/&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    // Event to handle Villager updating&#10;    @EventHandler&#10;    public void afterTrade(InventoryCloseEvent event) {&#10;&#10;        Player player = (Player) event.getPlayer();&#10;        if(player.hasPermission(&quot;avl.disable&quot;))&#10;            return;&#10;        // check if inventory belongs to a Villager Trade Screen&#10;        if (event.getInventory().getHolder() == null) return;&#10;        if (event.getInventory().getHolder() instanceof WanderingTrader) return;&#10;        if(event.getInventory().getType() != InventoryType.MERCHANT) return;&#10;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        // make sure the villager is disabled&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (VillagerUtilities.getMarker(vil, plugin)) return;&#10;&#10;        // handle leveling&#10;        VillagerLevelManager.call(vil, plugin, player);&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag.events;&#10;&#10;import org.bukkit.ChatColor;&#10;import org.bukkit.Material;&#10;import org.bukkit.entity.*;&#10;import org.bukkit.event.Listener;&#10;import org.bukkit.event.EventHandler;&#10;import org.bukkit.event.entity.EntityDamageByEntityEvent;&#10;import org.bukkit.event.inventory.InventoryClickEvent;&#10;import org.bukkit.event.inventory.InventoryCloseEvent;&#10;import org.bukkit.event.inventory.InventoryType;&#10;import org.bukkit.event.inventory.TradeSelectEvent;&#10;import org.bukkit.event.player.PlayerInteractEntityEvent;&#10;import org.bukkit.event.player.PlayerJoinEvent;&#10;import org.bukkit.inventory.ItemStack;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.UpdateChecker;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class EventListener implements Listener {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;&#10;    public EventListener(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;&#10;    @EventHandler&#10;    public void onRightClick(PlayerInteractEntityEvent event) {&#10;        if (event.isCancelled()) return;&#10;        Player player = event.getPlayer();&#10;        //  It's a villager&#10;        if (!event.getRightClicked().getType().equals(EntityType.VILLAGER)) return;&#10;        Villager villager = (Villager) event.getRightClicked();&#10;&#10;        //  Setup new Villagers&#10;        if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;            VillagerUtilities.setAiCooldown(villager, plugin, 0L);&#10;            VillagerUtilities.setLevelCooldown(villager, plugin, 0L);&#10;            VillagerUtilities.setLastRestock(villager, plugin);&#10;            VillagerUtilities.setMarker(villager, plugin, true);&#10;        }&#10;&#10;        //  Get Times&#10;        long currentTime = System.currentTimeMillis() / 1000;&#10;        long vilLevelCooldown = VillagerUtilities.getLevelCooldown(villager, plugin);&#10;        long vilAiCooldown = VillagerUtilities.getAiCooldown(villager, plugin);&#10;        long totalSeconds = vilAiCooldown - currentTime;&#10;        long sec = totalSeconds % 60;&#10;        long min = totalSeconds / 60;&#10;&#10;        //  If the villager is leveling up&#10;        if (vilLevelCooldown &gt; currentTime) {&#10;            String message = plugin.getConfig().getString(&quot;messages.cooldown-levelup-message&quot;);&#10;            long level_sec = vilLevelCooldown - currentTime;&#10;            message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(level_sec));&#10;            event.getPlayer().sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;            villager.shakeHead();&#10;            event.setCancelled(true);&#10;            return;&#10;        }&#10;&#10;        //  Should it be disabled?&#10;        boolean nametag_result = NameTagAI.call(villager, plugin, player);&#10;        boolean block_result = BlockAI.call(villager, plugin, player);&#10;        boolean workblock_result = WorkblockAI.call(villager, plugin, player);&#10;        boolean should_be_disabled = nametag_result || block_result || workblock_result;&#10;&#10;&#10;        //  If villager AI is being toggled&#10;        if (should_be_disabled == VillagerUtilities.getMarker(villager, plugin)) {&#10;            //  If toggling is on cooldown&#10;            if ((vilAiCooldown &gt; currentTime) &amp;&amp; !player.hasPermission(&quot;avl.cooldown.bypass&quot;)) {&#10;                //Tell player it's on cooldown&#10;                String message = plugin.getConfig().getString(&quot;messages.cooldown-ai-message&quot;);&#10;                message = message.replaceAll(&quot;%avlminutes%&quot;, Long.toString(min));&#10;                message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(sec));&#10;                event.getPlayer().sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;                event.setCancelled(true);&#10;            //  If cooldown is over&#10;            } else {&#10;                boolean wasOptimized = VillagerUtilities.getMarker(villager, plugin);&#10;                VillagerUtilities.setMarker(villager, plugin, !should_be_disabled);&#10;                villager.setAware(!should_be_disabled);&#10;                VillagerUtilities.setAiCooldown(villager, plugin, plugin.getConfig().getLong(&quot;ai-toggle-cooldown&quot;));&#10;                &#10;                // Enhanced feedback messages&#10;                if (!should_be_disabled) {&#10;                    // Villager was optimized, now being unoptimized (activated)&#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-unoptimized&quot;)));&#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-breeding-reminder&quot;)));&#10;                } else {&#10;                    // Villager was active, now being optimized (disabled)  &#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-optimized&quot;)));&#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-performance-tip&quot;)));&#10;                }&#10;                &#10;                //  If nametag shouldn't be consumed, give one back&#10;                if (player.getInventory().getItemInMainHand().getType().equals(Material.NAME_TAG) &amp;&amp; !plugin.getConfig().getBoolean(&quot;toggleableoptions.usenametags&quot;)) {&#10;                    ItemStack nametag = player.getInventory().getItemInMainHand();&#10;                    if (!nametag.getItemMeta().hasDisplayName()) return;&#10;                    player.getInventory().getItemInMainHand().setAmount(player.getInventory().getItemInMainHand().getAmount() + 1);&#10;                }&#10;            }&#10;        }&#10;        //  If the villager AI is not being toggled&#10;        else {&#10;            // Show current status to player&#10;            if (VillagerUtilities.getMarker(villager, plugin)) {&#10;                // Villager is optimized&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-status-optimized&quot;)));&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-info-optimized&quot;)));&#10;            } else {&#10;                // Villager is active  &#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-status-active&quot;)));&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-info-active&quot;)));&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.action-help&quot;)));&#10;            }&#10;            &#10;            //  If nametag shouldn't be consumed, give one back&#10;            if (!VillagerUtilities.hasMarker(villager, plugin)) return;&#10;            if (player.getInventory().getItemInMainHand().getType().equals(Material.NAME_TAG) &amp;&amp; !plugin.getConfig().getBoolean(&quot;toggleableoptions.usenametags&quot;)) {&#10;                ItemStack nametag = player.getInventory().getItemInMainHand();&#10;                if (!nametag.getItemMeta().hasDisplayName()) return;&#10;                player.getInventory().getItemInMainHand().setAmount(player.getInventory().getItemInMainHand().getAmount() + 1);&#10;            }&#10;        }&#10;&#10;        //  Restock&#10;        if (!VillagerUtilities.getMarker(villager, plugin)) {&#10;            RestockVillager.call(villager, plugin, player);&#10;        }&#10;    }&#10;&#10;    // Code for forcing players to disable villagers&#10;&#10;    @EventHandler&#10;    public void inventoryMove(InventoryClickEvent event) {&#10;        if (event.isCancelled()) return;&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.preventtrading&quot;)) return;&#10;        if (!(event.getInventory().getHolder() instanceof Villager)) return;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (!VillagerUtilities.getMarker(vil, plugin)) return;&#10;        Player player = (Player) event.getWhoClicked();&#10;        event.setCancelled(true);&#10;        //player.closeInventory();&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.VillagerMustBeDisabled&quot;)));&#10;    }&#10;&#10;    @EventHandler&#10;    public void villagerTradeClick(TradeSelectEvent event) {&#10;        if (event.isCancelled()) return;&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.preventtrading&quot;)) return;&#10;        if (!(event.getInventory().getHolder() instanceof Villager)) return;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (!VillagerUtilities.getMarker(vil, plugin)) return;&#10;        Player player = (Player) event.getWhoClicked();&#10;        event.setCancelled(true);&#10;        player.closeInventory();&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.VillagerMustBeDisabled&quot;)));&#10;    }&#10;&#10;    // Event to handle cancellation of damage to villagers disable by the plugin&#10;    @EventHandler&#10;    public void onCancelVillagerDamage(EntityDamageByEntityEvent event) {&#10;        if (event.isCancelled()) return;&#10;        if (!(event.getEntity() instanceof Villager &amp;&amp; event.getDamager() instanceof Zombie)) return;&#10;&#10;        Villager vil = (Villager) event.getEntity();&#10;&#10;        if (VillagerUtilities.hasMarker(vil, plugin) &amp;&amp; !VillagerUtilities.getMarker(vil, plugin)) {&#10;            event.setCancelled(true);&#10;        }&#10;    }&#10;&#10;    @EventHandler&#10;    public void playerJoin(PlayerJoinEvent event) {&#10;        if (!event.getPlayer().hasPermission(&quot;avl.notify.update&quot;)) return;&#10;        new UpdateChecker(plugin, 102949).getVersion(version -&gt; {&#10;            if (plugin.getDescription().getVersion().equals(version)) {&#10;                event.getPlayer().sendMessage(ChatColor.GREEN + &quot;AntiVillagerLag is up to date!&quot;);&#10;            } else {&#10;                event.getPlayer().sendMessage(ChatColor.GREEN + &quot;There is an update for AntiVillagerLag! https://www.spigotmc.org/resources/antivillagerlag.102949/&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    // Event to handle Villager updating&#10;    @EventHandler&#10;    public void afterTrade(InventoryCloseEvent event) {&#10;&#10;        Player player = (Player) event.getPlayer();&#10;        if(player.hasPermission(&quot;avl.disable&quot;))&#10;            return;&#10;        // check if inventory belongs to a Villager Trade Screen&#10;        if (event.getInventory().getHolder() == null) return;&#10;        if (event.getInventory().getHolder() instanceof WanderingTrader) return;&#10;        if(event.getInventory().getType() != InventoryType.MERCHANT) return;&#10;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        // make sure the villager is disabled&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (VillagerUtilities.getMarker(vil, plugin)) return;&#10;&#10;        // handle leveling&#10;        VillagerLevelManager.call(vil, plugin, player);&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/events/RestockVillager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/events/RestockVillager.java" />
              <option name="originalContent" value="package rebelmythik.antiVillagerLag.events;&#10;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class RestockVillager {&#10;&#10;    private static void restockMessage(long timeTillNextRestock, Player player, AntiVillagerLag plugin) {&#10;        long totalsec = timeTillNextRestock / 20;&#10;        long sec = totalsec % 60;&#10;        long min = (totalsec - sec) / 60;&#10;        String message = plugin.getConfig().getString(&quot;messages.next-restock&quot;);&#10;        message = message.replaceAll(&quot;%avlrestockmin%&quot;, Long.toString(min));&#10;        message = message.replaceAll(&quot;%avlrestocksec%&quot;, Long.toString(sec));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;    }&#10;&#10;    public static void call(Villager vil, AntiVillagerLag plugin, Player player) {&#10;&#10;        // Permission to Bypass restock cooldown&#10;        if (player.hasPermission(&quot;avl.restockcooldown.bypass&quot;)) {&#10;            VillagerUtilities.restock(vil);&#10;            VillagerUtilities.setLastRestock(vil, plugin);&#10;            return;&#10;        }&#10;&#10;        // Check if it's time to restock&#10;        long worldTick = vil.getWorld().getFullTime();&#10;        long currentDayTick = vil.getWorld().getTime();&#10;        long beginningOfDayTick = worldTick - currentDayTick;&#10;        long vilTick = VillagerUtilities.getLastRestock(vil, plugin);&#10;&#10;        for (long restockTime : VillagerUtilities.restock_times) {&#10;            long todayRestock = beginningOfDayTick + restockTime;&#10;            if (worldTick &gt;= todayRestock &amp;&amp; vilTick &lt; todayRestock) {&#10;                VillagerUtilities.restock(vil);&#10;                VillagerUtilities.setLastRestock(vil, plugin);&#10;                return;&#10;            }&#10;        }&#10;&#10;        // check if he gets to see cool-down time&#10;        if (player.hasPermission(&quot;avl.message.nextrestock&quot;)) {&#10;            long timeTillNextRestock = Long.MAX_VALUE;&#10;            for (long restockTime : VillagerUtilities.restock_times) {&#10;                long restockTick = beginningOfDayTick + restockTime;&#10;                if (worldTick &lt; restockTick) {&#10;                    timeTillNextRestock = Math.min(timeTillNextRestock, restockTick - worldTick);&#10;                }&#10;            }&#10;&#10;            if (timeTillNextRestock == Long.MAX_VALUE) {&#10;                timeTillNextRestock = (24000 + beginningOfDayTick + VillagerUtilities.restock_times.get(0)) - worldTick;&#10;            }&#10;&#10;            restockMessage(timeTillNextRestock, player, plugin);&#10;        }&#10;    }&#10;&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag.events;&#10;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class RestockVillager {&#10;&#10;    private static void restockMessage(long timeTillNextRestock, Player player, AntiVillagerLag plugin) {&#10;        long totalsec = timeTillNextRestock / 20;&#10;        long sec = totalsec % 60;&#10;        long min = (totalsec - sec) / 60;&#10;        String message = plugin.getConfig().getString(&quot;messages.next-restock&quot;);&#10;        message = message.replaceAll(&quot;%avlrestockmin%&quot;, Long.toString(min));&#10;        message = message.replaceAll(&quot;%avlrestocksec%&quot;, Long.toString(sec));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;    }&#10;&#10;    public static void call(Villager vil, AntiVillagerLag plugin, Player player) {&#10;&#10;        // Permission to Bypass restock cooldown&#10;        if (player.hasPermission(&quot;avl.restockcooldown.bypass&quot;)) {&#10;            VillagerUtilities.restock(vil);&#10;            VillagerUtilities.setLastRestock(vil, plugin);&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-restock-success&quot;)));&#10;            return;&#10;        }&#10;&#10;        // Check if it's time to restock&#10;        long worldTick = vil.getWorld().getFullTime();&#10;        long currentDayTick = vil.getWorld().getTime();&#10;        long beginningOfDayTick = worldTick - currentDayTick;&#10;        long vilTick = VillagerUtilities.getLastRestock(vil, plugin);&#10;&#10;        for (long restockTime : VillagerUtilities.restock_times) {&#10;            long todayRestock = beginningOfDayTick + restockTime;&#10;            if (worldTick &gt;= todayRestock &amp;&amp; vilTick &lt; todayRestock) {&#10;                VillagerUtilities.restock(vil);&#10;                VillagerUtilities.setLastRestock(vil, plugin);&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-restock-success&quot;)));&#10;                return;&#10;            }&#10;        }&#10;&#10;        // check if he gets to see cool-down time&#10;        if (player.hasPermission(&quot;avl.message.nextrestock&quot;)) {&#10;            long timeTillNextRestock = Long.MAX_VALUE;&#10;            for (long restockTime : VillagerUtilities.restock_times) {&#10;                long restockTick = beginningOfDayTick + restockTime;&#10;                if (worldTick &lt; restockTick) {&#10;                    timeTillNextRestock = Math.min(timeTillNextRestock, restockTick - worldTick);&#10;                }&#10;            }&#10;&#10;            if (timeTillNextRestock == Long.MAX_VALUE) {&#10;                timeTillNextRestock = (24000 + beginningOfDayTick + VillagerUtilities.restock_times.get(0)) - worldTick;&#10;            }&#10;&#10;            restockMessage(timeTillNextRestock, player, plugin);&#10;        }&#10;    }&#10;&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/events/VillagerLevelManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/events/VillagerLevelManager.java" />
              <option name="originalContent" value="package rebelmythik.antiVillagerLag.events;&#10;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import org.bukkit.potion.PotionEffect;&#10;import org.bukkit.potion.PotionEffectType;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.CalculateLevel;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class VillagerLevelManager {&#10;&#10;    public static void call(Villager vil, AntiVillagerLag plugin, Player player) {&#10;        int cooldown = 5;&#10;        int vilLevel = vil.getVillagerLevel();&#10;        long newLevel = CalculateLevel.villagerEXP(vil);&#10;        long currentTime = System.currentTimeMillis() / 1000;&#10;&#10;        long vilLevelCooldown = VillagerUtilities.getLevelCooldown(vil, plugin);&#10;        long totalSeconds = vilLevelCooldown - currentTime;&#10;        long sec = totalSeconds % 60;&#10;&#10;        if (vilLevelCooldown &gt; currentTime) {&#10;            String message = plugin.getConfig().getString(&quot;messages.cooldown-levelup-message&quot;);&#10;            message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(sec));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;            return;&#10;        }&#10;&#10;        if (vilLevel &lt; newLevel) {&#10;            VillagerUtilities.setLevelCooldown(vil, plugin, cooldown);&#10;            // make villager immovable while AI is disabled&#10;            vil.addPotionEffect(new PotionEffect(PotionEffectType.SLOW, (int)(cooldown * 20)+20, 120, false, false));&#10;            vil.setAware(true);&#10;        } else return;&#10;&#10;        Bukkit.getScheduler().scheduleSyncDelayedTask(plugin, () -&gt; {&#10;            vil.setAware(false);&#10;        }, 100L);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag.events;&#10;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import org.bukkit.potion.PotionEffect;&#10;import org.bukkit.potion.PotionEffectType;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.CalculateLevel;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class VillagerLevelManager {&#10;&#10;    public static void call(Villager vil, AntiVillagerLag plugin, Player player) {&#10;        int cooldown = 5;&#10;        int vilLevel = vil.getVillagerLevel();&#10;        long newLevel = CalculateLevel.villagerEXP(vil);&#10;        long currentTime = System.currentTimeMillis() / 1000;&#10;&#10;        long vilLevelCooldown = VillagerUtilities.getLevelCooldown(vil, plugin);&#10;        long totalSeconds = vilLevelCooldown - currentTime;&#10;        long sec = totalSeconds % 60;&#10;&#10;        if (vilLevelCooldown &gt; currentTime) {&#10;            String message = plugin.getConfig().getString(&quot;messages.cooldown-levelup-message&quot;);&#10;            message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(sec));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;            return;&#10;        }&#10;&#10;        if (vilLevel &lt; newLevel) {&#10;            VillagerUtilities.setLevelCooldown(vil, plugin, cooldown);&#10;            // Notify player that villager is leveling up&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-levelup-starting&quot;)));&#10;            // make villager immovable while AI is disabled&#10;            vil.addPotionEffect(new PotionEffect(PotionEffectType.SLOW, (int)(cooldown * 20)+20, 120, false, false));&#10;            vil.setAware(true);&#10;        } else return;&#10;&#10;        Bukkit.getScheduler().scheduleSyncDelayedTask(plugin, () -&gt; {&#10;            vil.setAware(false);&#10;            // Notify player that level up is complete&#10;            if (player.isOnline()) {&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-levelup-complete&quot;)));&#10;            }&#10;        }, 100L);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/config.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/config.yml" />
              <option name="updatedContent" value="# These names will cause the villager to be disabled when named with a nametag&#10;NamesThatDisable:&#10;  - Optimize&#10;  - Bonk&#10;&#10;# This needs to be a valid block ID to work.&#10;BlocksThatDisable:&#10;  - EMERALD_BLOCK&#10;  - DIAMOND_BLOCK&#10;&#10;# List of workstations that will disable mobs&#10;WorkstationsThatDisable:&#10;  - COMPOSTER&#10;  - SMOKER&#10;  - BARREL&#10;  - LOOM&#10;  - BLAST_FURNACE&#10;  - BREWING_STAND&#10;  - Cauldron&#10;  - FLETCHING_TABLE&#10;  - CARTOGRAPHY_TABLE&#10;  - LECTERN&#10;  - SMITHING_TABLE&#10;  - STONECUTTER&#10;  - GRINDSTONE&#10;&#10;# Please do the time in ticks or it will break the plugin. There is 24,000 ticks in a single day.&#10;# See https://minecraft.fandom.com/wiki/Daylight_cycle for more info&#10;RestockTimes:&#10;  times:&#10;    - 1000&#10;    - 13000&#10;&#10;# This time is in seconds. This cooldown is to prevent possible abuse&#10;# of people repeatedly disabling ai and re-enabling it to get double trades. I would keep this&#10;# at the minimum time of 10 minutes or 600 seconds due anything less allowing for the double trades to happen.&#10;ai-toggle-cooldown: 600&#10;&#10;# The maximum radius in blocks the /avloptimize command can search&#10;RadiusLimit: 50&#10;&#10;# the default radius for /avloptimize when no argument is specified&#10;RadiusDefault: 50&#10;&#10;toggleableoptions:&#10;  # Prevent trading with villagers when they aren't disabled. Still allows players to preview trades&#10;  preventtrading: true&#10;&#10;  # If set to true, nametags will be used instead of being infinite.&#10;  usenametags: false&#10;&#10;  # One of these following options needs to be true for the plugin to work.&#10;  ### This will allow nametags to disable and renable the Villager AI. This also effects the /avloptimize command&#10;  userenaming: true&#10;&#10;  ### This will allow a block to disable and renable the Villager AI.&#10;  useblocks: false&#10;&#10;  ### This feature will disable the villager if they have a workstation in the configurable radius in blocks of the villager&#10;  useworkstations: false&#10;  workstationcheckradius: 2&#10;&#10;# New ergonomic features for better user experience&#10;visual-feedback:&#10;  enabled: true&#10;  particles: true&#10;  sounds: true&#10;&#10;action-bar:&#10;  enabled: true&#10;  status-optimized: &quot;&amp;a[OPTIMIZED] &amp;7Ready for trading&quot;&#10;  status-active: &quot;&amp;e[ACTIVE] &amp;7Mobile villager&quot;&#10;  status-new: &quot;&amp;7[NEW] &amp;eRight-click to setup&quot;&#10;  cooldown: &quot;&amp;c⏰ Cooldown: %avlminutes%m %avlseconds%s&quot;&#10;&#10;messages:&#10;  no-permission: &quot;&amp;cYou don't have permission to use this command.&quot;&#10;  reload-message: &quot;&amp;aPlugin successfully reloaded.&quot;&#10;  cooldown-ai-message: &quot;&amp;cYou can toggle this villager's AI again in %avlminutes% minutes and %avlseconds% seconds.&quot;&#10;  cooldown-levelup-message: &quot;&amp;cThe villager is currently leveling up! You can use the villager again in %avlseconds% seconds.&quot;&#10;  next-restock: &quot;&amp;cThe next restock for the villager will be in %avlrestockmin% minutes and %avlrestocksec% seconds.&quot;&#10;  optimize-command-usage: &quot;&amp;cCorrect Usage is /avloptimize &lt;radius&gt;&quot;&#10;  unoptimize-command-usage: &quot;&amp;cCorrect Usage is /avlunoptimize &lt;radius&gt;&quot;&#10;  radius-limit: &quot;&amp;cThe radius you tried is too big. Radius limit is %avlradiuslimit% blocks.&quot;&#10;  VillagerMustBeDisabled: &quot;&amp;cYou need to disable the villager before you can trade with it&quot;&#10;  searching-radius: &quot;&amp;aSearching radius of %avlradius% blocks.&quot;&#10;  radius-invalid: &quot;&amp;cRadius must be a valid Integer.&quot;&#10;&#10;  # Enhanced feedback messages for better player experience&#10;  villager-optimized: &quot;&amp;a✓ Villager AI disabled! This villager is now optimized and consuming minimal server resources.&quot;&#10;  villager-unoptimized: &quot;&amp;e⚠ Villager AI enabled! This villager is now active and can move/breed.&quot;&#10;  villager-already-optimized: &quot;&amp;7This villager is already optimized (AI disabled).&quot;&#10;  villager-already-unoptimized: &quot;&amp;7This villager is already active (AI enabled).&quot;&#10;  villager-status-optimized: &quot;&amp;a[OPTIMIZED] &amp;7This villager's AI is disabled - ready for trading!&quot;&#10;  villager-status-active: &quot;&amp;e[ACTIVE] &amp;7This villager's AI is enabled - can move and breed.&quot;&#10;  villager-performance-tip: &quot;&amp;6 Tip: Keep villagers optimized when not breeding to improve server performance!&quot;&#10;  villager-breeding-reminder: &quot;&amp;6 Reminder: Unoptimize villagers temporarily if you need them to breed.&quot;&#10;  villager-zombie-protected: &quot;&amp;a This optimized villager is protected from zombie attacks!&quot;&#10;  villager-restock-success: &quot;&amp;a✅ Villager restocked successfully!&quot;&#10;  villager-levelup-starting: &quot;&amp;e⚡ Villager is leveling up... AI temporarily enabled.&quot;&#10;  villager-levelup-complete: &quot;&amp;a✅ Villager level up complete! AI optimization restored.&quot;&#10;  bulk-optimize-start: &quot;&amp;aStarting bulk optimization of villagers...&quot;&#10;  bulk-optimize-complete: &quot;&amp;a✅ Bulk optimization complete! &amp;7%avlcount% villagers optimized.&quot;&#10;  bulk-unoptimize-start: &quot;&amp;eStarting bulk unoptimization of villagers...&quot;&#10;  bulk-unoptimize-complete: &quot;&amp;e✅ Bulk unoptimization complete! &amp;7%avlcount% villagers activated.&quot;&#10;  performance-impact: &quot;&amp;a Performance Impact: &amp;7-%avlpercentage%% server load from optimized villagers.&quot;&#10;  action-help: &quot;&amp;6ℹ Right-click with 'Optimize' nametag to disable AI, or rename to anything else to enable AI.&quot;&#10;  villager-info-optimized: &quot;&amp;a[OPTIMIZED] &amp;7Status: Frozen, Trading: Available, Breeding: Disabled&quot;&#10;  villager-info-active: &quot;&amp;e[ACTIVE] &amp;7Status: Mobile, Trading: Restricted, Breeding: Enabled&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>