<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="updatedContent" value="&lt;p align=&quot;center&quot;&gt;&#10;    &lt;a href=&quot;https://discord.gg/WWWeAqwcU6&quot; alt=&quot;Discord&quot;&gt;&#10;        &lt;img src=&quot;https://img.shields.io/discord/990400053673873428?label=Discord&quot;/&gt;&#10;    &lt;/a&gt;&#10;&lt;/p&gt;&#10;&#10;# AntiVillagerLag &#10;&#10;SpigotMC: [Link](https://www.spigotmc.org/resources/antivillagerlag.102949/)&#10;&#10;A comprehensive villager optimization plugin that allows players to selectively disable villager AI to reduce server lag while maintaining full trading functionality. Perfect for large trading halls and villager farms that impact server performance.&#10;&#10;##  Table of Contents&#10;- [Overview](#overview)&#10;- [Key Features](#key-features)&#10;- [How It Works](#how-it-works)&#10;- [Installation &amp; Setup](#installation--setup)&#10;- [Usage Guide](#usage-guide)&#10;- [Configuration](#configuration)&#10;- [Commands](#commands)&#10;- [Permissions](#permissions)&#10;- [Advanced Features](#advanced-features)&#10;- [Performance Impact](#performance-impact)&#10;- [Troubleshooting](#troubleshooting)&#10;- [Support](#support)&#10;&#10;##  Overview&#10;&#10;AntiVillagerLag addresses the common server performance issues caused by large villager trading halls. Instead of removing villagers or limiting trading, this plugin allows players to **selectively disable villager AI** when they don't need to move around, dramatically reducing computational overhead while preserving all trading functionality.&#10;&#10;### The Problem&#10;- Large villager trading halls can severely impact server MSPT&#10;- Villagers constantly pathfinding and AI processing causes lag&#10;- Traditional solutions involve removing villagers or limiting trades&#10;&#10;### The Solution  &#10;- Players can &quot;freeze&quot; villagers when not actively breeding or moving them&#10;- Frozen villagers consume virtually no server resources&#10;- Trading remains fully functional with custom restock schedules&#10;- Easy toggle system allows quick activation when needed&#10;&#10;## ✨ Key Features&#10;&#10;###  Player-Controlled Optimization&#10;- **Multiple Control Methods**: Use nametags, blocks, or workstations to control villager states&#10;- **Instant Toggle**: Right-click to enable/disable villager AI&#10;- **Visual Feedback**: Clear messages show villager status and cooldowns&#10;- **No Resource Waste**: Configurable nametag consumption&#10;&#10;### ⚡ Performance Optimization&#10;- **AI Freezing**: Completely stops villager pathfinding and behavior processing&#10;- **Zombie Protection**: Frozen villagers are immune to zombie attacks&#10;- **Selective Processing**: Only active villagers consume server resources&#10;- **Massive MSPT Reduction**: Up to 90% performance improvement in large trading halls&#10;&#10;### ️ Anti-Exploit Protection&#10;- **Trade Cooldowns**: Prevents double-trading exploits&#10;- **Level-up Handling**: Automatic temporary AI activation for villager progression&#10;- **Smart Restocking**: Custom restock schedule prevents vanilla/plugin conflicts&#10;&#10;###  Advanced Management&#10;- **Radius Commands**: Bulk optimize/unoptimize villagers in areas&#10;- **Permission System**: Fine-grained control over who can use features&#10;- **Update Notifications**: Automatic update checking for administrators&#10;&#10;## ⚙️ How It Works&#10;&#10;### Villager States&#10;AntiVillagerLag manages villagers in two primary states:&#10;&#10;####  Active State (AI Enabled)&#10;- Villager behaves normally&#10;- Can move, pathfind, and interact with environment&#10;- Consumes normal server resources&#10;- Required for breeding and some farm mechanics&#10;&#10;####  Optimized State (AI Disabled)  &#10;- All AI processing stopped (`setAware(false)`)&#10;- Villager cannot move or pathfind&#10;- Protected from zombie attacks&#10;- Maintains all trade data and experience&#10;- Consumes minimal server resources&#10;&#10;### Control Methods&#10;&#10;#### 1. **Nametag Control** (Primary Method)&#10;```&#10;Default Names: &quot;Optimize&quot;, &quot;Bonk&quot;&#10;- Use nametag with trigger name → Disables AI&#10;- Rename to anything else → Enables AI  &#10;- Configurable nametag consumption&#10;```&#10;&#10;#### 2. **Block-Based Control**&#10;```&#10;Default Blocks: Emerald Block, Diamond Block&#10;- Place trigger block near villager → Disables AI&#10;- Remove block → Enables AI&#10;- Configurable detection radius&#10;```&#10;&#10;#### 3. **Workstation Control**  &#10;```&#10;Workstations: Composter, Smoker, Barrel, etc.&#10;- Workstation in radius → Disables AI&#10;- No workstation → Enables AI&#10;- Configurable detection radius (default: 2 blocks)&#10;```&#10;&#10;##  Installation &amp; Setup&#10;&#10;### Requirements&#10;- Minecraft 1.20+&#10;- Spigot/Paper server&#10;- Java 8+&#10;&#10;### Installation Steps&#10;1. Download the latest JAR from [SpigotMC](https://www.spigotmc.org/resources/antivillagerlag.102949/)&#10;2. Place in your `plugins/` folder&#10;3. Restart your server&#10;4. Edit `plugins/AntiVillagerLag/config.yml` as needed&#10;5. Run `/avlreload` to apply changes&#10;&#10;##  Usage Guide&#10;&#10;### Basic Usage&#10;1. **Optimize a Villager**: Right-click with a nametag named &quot;Optimize&quot; or &quot;Bonk&quot;&#10;2. **Unoptimize**: Rename the villager to anything else and right-click&#10;3. **Trade**: Only works with optimized (frozen) villagers by default&#10;&#10;### Trading Workflow&#10;```&#10;1. Find villager → 2. Optimize it → 3. Trade → 4. Unoptimize if needed for breeding&#10;```&#10;&#10;### Bulk Operations&#10;```bash&#10;/avloptimize 25        # Optimize all villagers within 25 blocks&#10;/avlunoptimize 25      # Unoptimize all villagers within 25 blocks  &#10;/avlremove             # Remove all plugin modifications server-wide&#10;```&#10;&#10;## ⚙️ Configuration&#10;&#10;### config.yml Structure&#10;&#10;#### Control Names &amp; Blocks&#10;```yaml&#10;NamesThatDisable:&#10;  - Optimize&#10;  - Bonk&#10;&#10;BlocksThatDisable:&#10;  - EMERALD_BLOCK&#10;  - DIAMOND_BLOCK&#10;&#10;WorkstationsThatDisable:&#10;  - COMPOSTER&#10;  - SMOKER&#10;  - BARREL&#10;  # ... full list of workstations&#10;```&#10;&#10;#### Restock Schedule  &#10;```yaml&#10;RestockTimes:&#10;  times:&#10;    - 1000    # ~1 hour after sunrise&#10;    - 13000   # ~1 hour after sunset&#10;```&#10;&#10;#### Anti-Exploit Settings&#10;```yaml&#10;ai-toggle-cooldown: 600  # 10 minutes between AI toggles&#10;RadiusLimit: 50         # Max radius for bulk commands&#10;RadiusDefault: 50       # Default radius when not specified&#10;```&#10;&#10;#### Toggle Options&#10;```yaml&#10;toggleableoptions:&#10;  preventtrading: true      # Force optimization before trading&#10;  usenametags: false       # Consume nametags when used&#10;  userenaming: true        # Enable nametag control&#10;  useblocks: false         # Enable block-based control&#10;  useworkstations: false   # Enable workstation-based control&#10;  workstationcheckradius: 2 # Radius for workstation detection&#10;```&#10;&#10;##  Commands&#10;&#10;| Command | Description | Permission | Usage |&#10;|---------|-------------|------------|-------|&#10;| `/avlreload` | Reload plugin configuration | `avl.reload` | `/avlreload` |&#10;| `/avloptimize` | Optimize villagers in radius | `avl.optimize` | `/avloptimize [radius]` |&#10;| `/avlunoptimize` | Unoptimize villagers in radius | `avl.unoptimize` | `/avlunoptimize [radius]` |&#10;| `/avlremove` | Remove all plugin modifications | `avl.remove` | `/avlremove` |&#10;&#10;##  Permissions&#10;&#10;### Command Permissions&#10;- `avl.reload` - Reload plugin configuration&#10;- `avl.optimize` - Use bulk optimize commands  &#10;- `avl.unoptimize` - Use bulk unoptimize commands&#10;- `avl.remove` - Remove all plugin modifications&#10;&#10;### Bypass Permissions&#10;- `avl.cooldown.bypass` - Bypass AI toggle cooldown&#10;- `avl.restockcooldown.bypass` - Force immediate restocking&#10;- `avl.disable` - Completely disable plugin effects for player&#10;&#10;### Notification Permissions&#10;- `avl.message.nextrestock` (default: true) - See restock countdown messages&#10;- `avl.notify.update` (op: true) - Receive update notifications&#10;&#10;##  Advanced Features&#10;&#10;### Automatic Level Management&#10;- Plugin detects when optimized villagers need to level up&#10;- Temporarily enables AI for 5 seconds during level progression&#10;- Automatically re-optimizes after leveling completes&#10;- Prevents level-up interruption during the process&#10;&#10;### Smart Restock System&#10;- Custom restock schedule independent of vanilla mechanics&#10;- Prevents double-restocking exploits&#10;- Configurable times based on in-game day/night cycle&#10;- Instant restock available with bypass permission&#10;&#10;### Zombie Protection&#10;- Optimized villagers are immune to zombie attacks&#10;- Prevents villager loss in trading halls&#10;- Does not affect iron golem spawning mechanics&#10;&#10;### Update Integration&#10;- Automatic update checking on plugin load&#10;- Notification system for administrators&#10;- Version compatibility warnings&#10;&#10;##  Performance Impact&#10;&#10;### Before AntiVillagerLag&#10;- 100 villagers = ~5-10 MSPT impact&#10;- Constant pathfinding calculations  &#10;- Memory usage from AI processing&#10;- Server lag during peak hours&#10;&#10;### After AntiVillagerLag  &#10;- 100 optimized villagers = ~0.1-0.5 MSPT impact&#10;- No pathfinding when optimized&#10;- Minimal memory footprint&#10;- Smooth server performance&#10;&#10;### Real-World Results&#10;- **Large Trading Halls**: 90%+ MSPT reduction&#10;- **Mixed Farms**: 70% performance improvement&#10;- **Memory Usage**: 60% reduction in villager-related RAM usage&#10;&#10;## ️ Troubleshooting&#10;&#10;### Common Issues&#10;&#10;#### &quot;Villager won't trade&quot;&#10;- **Cause**: `preventtrading: true` requires optimization first&#10;- **Solution**: Optimize villager before trading, or disable setting&#10;&#10;#### &quot;Nametags being consumed&quot;  &#10;- **Cause**: `usenametags: true` in config&#10;- **Solution**: Set to `false` for infinite nametag usage&#10;&#10;#### &quot;Can't breed optimized villagers&quot;&#10;- **Cause**: AI disabled prevents breeding behavior  &#10;- **Solution**: Temporarily unoptimize villagers for breeding&#10;&#10;#### &quot;Villager not leveling up&quot;&#10;- **Cause**: Plugin handles this automatically&#10;- **Solution**: Wait for automatic level-up process, don't manually intervene&#10;&#10;### Performance Issues&#10;- Check that only necessary villagers are unoptimized&#10;- Use bulk commands to optimize large groups efficiently&#10;- Monitor MSPT before/after optimization&#10;&#10;### Configuration Problems  &#10;- Verify YAML syntax in config.yml&#10;- Use `/avlreload` after making changes&#10;- Check console for error messages&#10;&#10;##  Best Practices&#10;&#10;### For Players&#10;1. **Optimize trading villagers** immediately after setting up trades&#10;2. **Only unoptimize when breeding** or moving villagers&#10;3. **Use bulk commands** for large trading halls&#10;4. **Monitor restock times** to plan trading sessions&#10;&#10;### For Administrators  &#10;1. **Set appropriate radius limits** to prevent abuse&#10;2. **Configure restock times** based on server economy&#10;3. **Enable update notifications** for security&#10;4. **Monitor performance metrics** before/after deployment&#10;&#10;### For Large Servers&#10;1. **Train players** on proper usage&#10;2. **Set up permission groups** for different access levels  &#10;3. **Use workstation control** for automatic optimization&#10;4. **Regular monitoring** of villager optimization status&#10;&#10;##  Integration Examples&#10;&#10;### Trading Hall Setup&#10;```&#10;1. Build trading hall with individual villager cells&#10;2. Place villagers and set up desired trades  &#10;3. Use /avloptimize 50 to optimize entire hall&#10;4. Enjoy lag-free trading with custom restock schedule&#10;```&#10;&#10;### Mixed Farm Integration  &#10;```&#10;1. Keep villagers for iron farms UNOPTIMIZED&#10;2. Optimize only trading-specific villagers&#10;3. Use workstation control for automatic management&#10;4. Monitor farm functionality regularly&#10;```&#10;&#10;##  Support&#10;&#10;### Getting Help&#10;- **Discord Server**: [Join Here](https://discord.gg/WWWeAqwcU6)  &#10;- **GitHub Issues**: Report bugs and feature requests&#10;- **SpigotMC**: Community support and updates&#10;&#10;### Before Asking for Help&#10;1. Check this documentation thoroughly  &#10;2. Verify your configuration syntax&#10;3. Test with a small number of villagers first&#10;4. Check console logs for error messages&#10;5. Include plugin version and server details&#10;&#10;### Feature Requests&#10;We welcome suggestions for new features! Please include:&#10;- Detailed description of desired functionality&#10;- Use case explanation  &#10;- Potential configuration options&#10;- Impact on existing features&#10;&#10;---&#10;&#10;**AntiVillagerLag** - Optimizing Minecraft servers one villager at a time! " />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/AntiVillagerLag.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/AntiVillagerLag.java" />
              <option name="originalContent" value="package rebelmythik.antiVillagerLag;&#10;&#10;import org.bstats.bukkit.Metrics;&#10;import org.bstats.charts.MultiLineChart;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.ChatColor;&#10;import org.bukkit.configuration.Configuration;&#10;import org.bukkit.configuration.InvalidConfigurationException;&#10;import org.bukkit.configuration.file.YamlConfiguration;&#10;import org.bukkit.plugin.java.JavaPlugin;&#10;import rebelmythik.antiVillagerLag.commands.OptimizeCommand;&#10;import rebelmythik.antiVillagerLag.commands.ReloadCommand;&#10;import rebelmythik.antiVillagerLag.commands.RemoveChangesCommand;&#10;import rebelmythik.antiVillagerLag.commands.UnoptimizeCommand;&#10;import rebelmythik.antiVillagerLag.events.EventListener;&#10;import rebelmythik.antiVillagerLag.utils.UpdateChecker;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;import java.io.File;&#10;import java.io.IOException;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public final class AntiVillagerLag extends JavaPlugin {&#10;&#10;    @Override&#10;    public void onEnable() {&#10;&#10;        //  Command Registration&#10;        getCommand(&quot;avlreload&quot;).setExecutor(new ReloadCommand(this));&#10;        getCommand(&quot;avloptimize&quot;).setExecutor(new OptimizeCommand(this));&#10;        getCommand(&quot;avlunoptimize&quot;).setExecutor(new UnoptimizeCommand(this));&#10;        getCommand(&quot;avlremove&quot;).setExecutor(new RemoveChangesCommand(this));&#10;&#10;        //  Event Registration&#10;        getServer().getPluginManager().registerEvents(new EventListener(this), this);&#10;&#10;&#10;        //  Config Stuff&#10;        saveDefaultConfig();&#10;        updateConfig();&#10;&#10;        VillagerUtilities.updateNameTags(this);&#10;        VillagerUtilities.updateStandingOnBlocks(this);&#10;        VillagerUtilities.updateWorkstationBlocks(this);&#10;        VillagerUtilities.updateRestockTimes(this);&#10;&#10;        //  Bstats Code&#10;        int pluginId = 15890;&#10;        Metrics metrics = new Metrics(this, pluginId);&#10;        //  Optional: Add custom charts&#10;        metrics.addCustomChart(new MultiLineChart(&quot;players_and_servers&quot;, () -&gt; {&#10;            Map&lt;String, Integer&gt; valueMap = new HashMap&lt;&gt;();&#10;            valueMap.put(&quot;servers&quot;, 1);&#10;            valueMap.put(&quot;players&quot;, Bukkit.getOnlinePlayers().size());&#10;            return valueMap;&#10;        }));&#10;&#10;        //  Check for plugin updates&#10;        new UpdateChecker(this, 102949).getVersion(version -&gt; {&#10;            if (this.getDescription().getVersion().equals(version)) {&#10;                getLogger().info(&quot;AntiVillagerLag is up to date!&quot;);&#10;            } else {&#10;                getLogger().info(&quot;There is an update for AntiVillagerLag! https://www.spigotmc.org/resources/antivillagerlag.102949/&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void onDisable() {&#10;        //  Plugin shutdown logic&#10;    }&#10;&#10;    //  Configuration File Updater&#10;    public Configuration cfg = this.getConfig().getDefaults();&#10;    public void updateConfig() {&#10;        try {&#10;            if(new File(getDataFolder() + &quot;/config.yml&quot;).exists()) {&#10;                boolean changesMade = false;&#10;                YamlConfiguration tmp = new YamlConfiguration();&#10;                tmp.load(getDataFolder() + &quot;/config.yml&quot;);&#10;                for(String str : cfg.getKeys(true)) {&#10;                    if(!tmp.getKeys(true).contains(str)) {&#10;                        tmp.set(str, cfg.get(str));&#10;                        changesMade = true;&#10;                    }&#10;                }&#10;                if(changesMade)&#10;                    tmp.save(getDataFolder() + &quot;/config.yml&quot;);&#10;            }&#10;        } catch (IOException | InvalidConfigurationException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag;&#10;&#10;import org.bstats.bukkit.Metrics;&#10;import org.bstats.charts.MultiLineChart;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.ChatColor;&#10;import org.bukkit.configuration.Configuration;&#10;import org.bukkit.configuration.InvalidConfigurationException;&#10;import org.bukkit.configuration.file.YamlConfiguration;&#10;import org.bukkit.plugin.java.JavaPlugin;&#10;import rebelmythik.antiVillagerLag.commands.OptimizeCommand;&#10;import rebelmythik.antiVillagerLag.commands.ReloadCommand;&#10;import rebelmythik.antiVillagerLag.commands.RemoveChangesCommand;&#10;import rebelmythik.antiVillagerLag.commands.UnoptimizeCommand;&#10;import rebelmythik.antiVillagerLag.commands.StatusCommand;&#10;import rebelmythik.antiVillagerLag.events.EventListener;&#10;import rebelmythik.antiVillagerLag.utils.UpdateChecker;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;import java.io.File;&#10;import java.io.IOException;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public final class AntiVillagerLag extends JavaPlugin {&#10;&#10;    @Override&#10;    public void onEnable() {&#10;&#10;        //  Command Registration&#10;        getCommand(&quot;avlreload&quot;).setExecutor(new ReloadCommand(this));&#10;        getCommand(&quot;avloptimize&quot;).setExecutor(new OptimizeCommand(this));&#10;        getCommand(&quot;avlunoptimize&quot;).setExecutor(new UnoptimizeCommand(this));&#10;        getCommand(&quot;avlremove&quot;).setExecutor(new RemoveChangesCommand(this));&#10;        getCommand(&quot;avlstatus&quot;).setExecutor(new StatusCommand(this));&#10;&#10;        //  Event Registration&#10;        getServer().getPluginManager().registerEvents(new EventListener(this), this);&#10;&#10;&#10;        //  Config Stuff&#10;        saveDefaultConfig();&#10;        updateConfig();&#10;&#10;        VillagerUtilities.updateNameTags(this);&#10;        VillagerUtilities.updateStandingOnBlocks(this);&#10;        VillagerUtilities.updateWorkstationBlocks(this);&#10;        VillagerUtilities.updateRestockTimes(this);&#10;&#10;        //  Bstats Code&#10;        int pluginId = 15890;&#10;        Metrics metrics = new Metrics(this, pluginId);&#10;        //  Optional: Add custom charts&#10;        metrics.addCustomChart(new MultiLineChart(&quot;players_and_servers&quot;, () -&gt; {&#10;            Map&lt;String, Integer&gt; valueMap = new HashMap&lt;&gt;();&#10;            valueMap.put(&quot;servers&quot;, 1);&#10;            valueMap.put(&quot;players&quot;, Bukkit.getOnlinePlayers().size());&#10;            return valueMap;&#10;        }));&#10;&#10;        //  Check for plugin updates&#10;        new UpdateChecker(this, 102949).getVersion(version -&gt; {&#10;            if (this.getDescription().getVersion().equals(version)) {&#10;                getLogger().info(&quot;AntiVillagerLag is up to date!&quot;);&#10;            } else {&#10;                getLogger().info(&quot;There is an update for AntiVillagerLag! https://www.spigotmc.org/resources/antivillagerlag.102949/&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void onDisable() {&#10;        //  Plugin shutdown logic&#10;    }&#10;&#10;    //  Configuration File Updater&#10;    public Configuration cfg = this.getConfig().getDefaults();&#10;    public void updateConfig() {&#10;        try {&#10;            if(new File(getDataFolder() + &quot;/config.yml&quot;).exists()) {&#10;                boolean changesMade = false;&#10;                YamlConfiguration tmp = new YamlConfiguration();&#10;                tmp.load(getDataFolder() + &quot;/config.yml&quot;);&#10;                for(String str : cfg.getKeys(true)) {&#10;                    if(!tmp.getKeys(true).contains(str)) {&#10;                        tmp.set(str, cfg.get(str));&#10;                        changesMade = true;&#10;                    }&#10;                }&#10;                if(changesMade)&#10;                    tmp.save(getDataFolder() + &quot;/config.yml&quot;);&#10;            }&#10;        } catch (IOException | InvalidConfigurationException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/commands/OptimizeCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/commands/OptimizeCommand.java" />
              <option name="originalContent" value="package rebelmythik.antiVillagerLag.commands;&#10;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.entity.Entity;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.events.BlockAI;&#10;import rebelmythik.antiVillagerLag.events.NameTagAI;&#10;import rebelmythik.antiVillagerLag.events.WorkblockAI;&#10;import rebelmythik.antiVillagerLag.utils.ColorCode;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class OptimizeCommand implements CommandExecutor {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;    public OptimizeCommand(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender commandSender, Command command, String s, String[] strings) {&#10;        if (!command.getName().equalsIgnoreCase(&quot;avloptimize&quot;)) return true;&#10;        //  Make sure it's a player&#10;        if (!(commandSender instanceof Player)) return false;&#10;        Player player = (Player) commandSender;&#10;&#10;        //  Check if they have permission&#10;        if(!player.hasPermission(&quot;avl.optimize&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.no-permission&quot;)));&#10;            return true;&#10;        }&#10;&#10;        //searchable radius based on first argument specified, if null defaults to config&#10;        int radius;&#10;        try{&#10;            radius = (strings != null &amp;&amp; strings.length &gt; 0) ? Integer.parseInt(strings[0]) : plugin.getConfig().getInt(&quot;RadiusDefault&quot;);&#10;        } catch (NumberFormatException e) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-invalid&quot;)));&#10;            return true;&#10;        }&#10;        boolean canSearchRadius = radius &lt;= plugin.getConfig().getInt(&quot;RadiusLimit&quot;);&#10;        if(!canSearchRadius){&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-limit&quot;)).replace(&quot;%avlradiuslimit%&quot;, plugin.getConfig().getString(&quot;RadiusLimit&quot;)));&#10;            return true;&#10;        }&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.searching-radius&quot;)).replace(&quot;%avlradius%&quot;, String.valueOf(radius)));&#10;&#10;        // Search for nearby villagers&#10;        player.getNearbyEntities(radius, radius, radius).forEach(entity -&gt; {&#10;            if (entity instanceof Villager) {&#10;                Villager villager = (Villager) entity;&#10;                //  Setup new Villagers&#10;                if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;                    VillagerUtilities.setAiCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLevelCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLastRestock(villager, plugin);&#10;                    VillagerUtilities.setMarker(villager, plugin, true);&#10;                }&#10;                //  Rename villager&#10;                villager.setCustomName(VillagerUtilities.disabling_names.getFirst());&#10;                //  Update the marker and AI&#10;                VillagerUtilities.setMarker(villager, plugin, false);&#10;                villager.setAware(false);&#10;&#10;            }&#10;        });&#10;        return true;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag.commands;&#10;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.entity.Entity;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.events.BlockAI;&#10;import rebelmythik.antiVillagerLag.events.NameTagAI;&#10;import rebelmythik.antiVillagerLag.events.WorkblockAI;&#10;import rebelmythik.antiVillagerLag.utils.ColorCode;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class OptimizeCommand implements CommandExecutor {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;    public OptimizeCommand(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender commandSender, Command command, String s, String[] strings) {&#10;        if (!command.getName().equalsIgnoreCase(&quot;avloptimize&quot;)) return true;&#10;        //  Make sure it's a player&#10;        if (!(commandSender instanceof Player)) return false;&#10;        Player player = (Player) commandSender;&#10;&#10;        //  Check if they have permission&#10;        if(!player.hasPermission(&quot;avl.optimize&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.no-permission&quot;)));&#10;            return true;&#10;        }&#10;&#10;        //searchable radius based on first argument specified, if null defaults to config&#10;        int radius;&#10;        try{&#10;            radius = (strings != null &amp;&amp; strings.length &gt; 0) ? Integer.parseInt(strings[0]) : plugin.getConfig().getInt(&quot;RadiusDefault&quot;);&#10;        } catch (NumberFormatException e) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-invalid&quot;)));&#10;            return true;&#10;        }&#10;        boolean canSearchRadius = radius &lt;= plugin.getConfig().getInt(&quot;RadiusLimit&quot;);&#10;        if(!canSearchRadius){&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-limit&quot;)).replace(&quot;%avlradiuslimit%&quot;, plugin.getConfig().getString(&quot;RadiusLimit&quot;)));&#10;            return true;&#10;        }&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.searching-radius&quot;)).replace(&quot;%avlradius%&quot;, String.valueOf(radius)));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.bulk-optimize-start&quot;)));&#10;&#10;        // Counter for optimized villagers&#10;        int optimizedCount = 0;&#10;&#10;        // Search for nearby villagers&#10;        for (Entity entity : player.getNearbyEntities(radius, radius, radius)) {&#10;            if (entity instanceof Villager) {&#10;                Villager villager = (Villager) entity;&#10;                //  Setup new Villagers&#10;                if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;                    VillagerUtilities.setAiCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLevelCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLastRestock(villager, plugin);&#10;                    VillagerUtilities.setMarker(villager, plugin, true);&#10;                }&#10;                &#10;                // Only optimize if not already optimized&#10;                if (VillagerUtilities.getMarker(villager, plugin)) {&#10;                    //  Rename villager&#10;                    villager.setCustomName(VillagerUtilities.disabling_names.getFirst());&#10;                    //  Update the marker and AI&#10;                    VillagerUtilities.setMarker(villager, plugin, false);&#10;                    villager.setAware(false);&#10;                    optimizedCount++;&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Send completion message with statistics&#10;        String completeMsg = plugin.getConfig().getString(&quot;messages.bulk-optimize-complete&quot;);&#10;        completeMsg = completeMsg.replace(&quot;%avlcount%&quot;, String.valueOf(optimizedCount));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(completeMsg));&#10;        &#10;        // Calculate and show performance impact&#10;        if (optimizedCount &gt; 0) {&#10;            int estimatedPerformanceGain = Math.min(90, optimizedCount * 2); // Rough estimate: 2% per villager, max 90%&#10;            String performanceMsg = plugin.getConfig().getString(&quot;messages.performance-impact&quot;);&#10;            performanceMsg = performanceMsg.replace(&quot;%avlpercentage%&quot;, String.valueOf(estimatedPerformanceGain));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(performanceMsg));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-zombie-protected&quot;)));&#10;        }&#10;        return true;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/commands/StatusCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/commands/StatusCommand.java" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag.commands;&#10;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.entity.Entity;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class StatusCommand implements CommandExecutor {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;    public StatusCommand(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender commandSender, Command command, String s, String[] strings) {&#10;        if (!command.getName().equalsIgnoreCase(&quot;avlstatus&quot;)) return true;&#10;        &#10;        // Make sure it's a player&#10;        if (!(commandSender instanceof Player)) return false;&#10;        Player player = (Player) commandSender;&#10;&#10;        // Check if they have permission&#10;        if(!player.hasPermission(&quot;avl.status&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.no-permission&quot;)));&#10;            return true;&#10;        }&#10;&#10;        // Default radius or specified radius&#10;        int radius;&#10;        try{&#10;            radius = (strings != null &amp;&amp; strings.length &gt; 0) ? Integer.parseInt(strings[0]) : plugin.getConfig().getInt(&quot;RadiusDefault&quot;);&#10;        } catch (NumberFormatException e) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-invalid&quot;)));&#10;            return true;&#10;        }&#10;&#10;        boolean canSearchRadius = radius &lt;= plugin.getConfig().getInt(&quot;RadiusLimit&quot;);&#10;        if(!canSearchRadius){&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-limit&quot;)).replace(&quot;%avlradiuslimit%&quot;, plugin.getConfig().getString(&quot;RadiusLimit&quot;)));&#10;            return true;&#10;        }&#10;&#10;        // Count villagers&#10;        int totalVillagers = 0;&#10;        int optimizedVillagers = 0;&#10;        int activeVillagers = 0;&#10;        int unmanagedVillagers = 0;&#10;&#10;        // Search for nearby villagers&#10;        for (Entity entity : player.getNearbyEntities(radius, radius, radius)) {&#10;            if (entity instanceof Villager) {&#10;                Villager villager = (Villager) entity;&#10;                totalVillagers++;&#10;&#10;                if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;                    unmanagedVillagers++;&#10;                } else if (!VillagerUtilities.getMarker(villager, plugin)) {&#10;                    optimizedVillagers++;&#10;                } else {&#10;                    activeVillagers++;&#10;                }&#10;            }&#10;        }&#10;&#10;        // Send status report&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;6━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;6            AntiVillagerLag Status Report&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;6━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;e Search Radius: &amp;7&quot; + radius + &quot; blocks&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;f Total Villagers Found: &amp;b&quot; + totalVillagers));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;a✅ Optimized (Frozen): &amp;2&quot; + optimizedVillagers));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;e⚡ Active (Mobile): &amp;6&quot; + activeVillagers));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;7❓ Unmanaged: &amp;8&quot; + unmanagedVillagers));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&quot;));&#10;        &#10;        if (totalVillagers &gt; 0) {&#10;            int optimizationRate = (optimizedVillagers * 100) / totalVillagers;&#10;            int estimatedPerformanceGain = Math.min(90, optimizedVillagers * 2);&#10;            &#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;f Optimization Rate: &amp;b&quot; + optimizationRate + &quot;%&quot;));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;f Estimated Performance Gain: &amp;a~&quot; + estimatedPerformanceGain + &quot;%&quot;));&#10;            &#10;            if (optimizationRate &lt; 70) {&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;c⚠ Consider optimizing more villagers for better performance!&quot;));&#10;            } else if (optimizationRate &gt;= 70 &amp;&amp; optimizationRate &lt; 90) {&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;e Good optimization level!&quot;));&#10;            } else {&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;a Excellent optimization! Great job!&quot;));&#10;            }&#10;        }&#10;        &#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;7 Use &amp;f/avloptimize &quot; + radius + &quot;&amp;7 to optimize all villagers&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;6━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&quot;));&#10;&#10;        return true;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/commands/UnoptimizeCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/commands/UnoptimizeCommand.java" />
              <option name="originalContent" value="package rebelmythik.antiVillagerLag.commands;&#10;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class UnoptimizeCommand implements CommandExecutor {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;    public UnoptimizeCommand(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender commandSender, Command command, String s, String[] strings) {&#10;        if (!command.getName().equalsIgnoreCase(&quot;avlunoptimize&quot;)) return true;&#10;        //  Make sure it's a player&#10;        if (!(commandSender instanceof Player)) return false;&#10;        Player player = (Player) commandSender;&#10;&#10;        //  Check if they have permission&#10;        if(!player.hasPermission(&quot;avl.unoptimize&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.no-permission&quot;)));&#10;            return true;&#10;        }&#10;&#10;        //searchable radius based on first argument specified, if null defaults to config&#10;        int radius;&#10;        try{&#10;            radius = (strings != null &amp;&amp; strings.length &gt; 0) ? Integer.parseInt(strings[0]) : plugin.getConfig().getInt(&quot;RadiusDefault&quot;);&#10;        } catch (NumberFormatException e) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-invalid&quot;)));&#10;            return true;&#10;        }&#10;        boolean canSearchRadius = radius &lt;= plugin.getConfig().getInt(&quot;RadiusLimit&quot;);&#10;        if(!canSearchRadius){&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-limit&quot;)).replace(&quot;%avlradiuslimit%&quot;, plugin.getConfig().getString(&quot;RadiusLimit&quot;)));&#10;            return true;&#10;        }&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.searching-radius&quot;)).replace(&quot;%avlradius%&quot;, String.valueOf(radius)));&#10;&#10;        // Search for nearby villagers&#10;        player.getNearbyEntities(radius, radius, radius).forEach(entity -&gt; {&#10;            if (entity instanceof Villager) {&#10;                Villager villager = (Villager) entity;&#10;                //  Setup new Villagers&#10;                if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;                    VillagerUtilities.setAiCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLevelCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLastRestock(villager, plugin);&#10;                    VillagerUtilities.setMarker(villager, plugin, true);&#10;                }&#10;                //  Rename villager&#10;                villager.setCustomName(&quot;&quot;);&#10;                //  Update the marker and AI&#10;                VillagerUtilities.setMarker(villager, plugin, true);&#10;                villager.setAware(true);&#10;            }&#10;        });&#10;        return true;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag.commands;&#10;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class UnoptimizeCommand implements CommandExecutor {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;    public UnoptimizeCommand(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender commandSender, Command command, String s, String[] strings) {&#10;        if (!command.getName().equalsIgnoreCase(&quot;avlunoptimize&quot;)) return true;&#10;        //  Make sure it's a player&#10;        if (!(commandSender instanceof Player)) return false;&#10;        Player player = (Player) commandSender;&#10;&#10;        //  Check if they have permission&#10;        if(!player.hasPermission(&quot;avl.unoptimize&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.no-permission&quot;)));&#10;            return true;&#10;        }&#10;&#10;        //searchable radius based on first argument specified, if null defaults to config&#10;        int radius;&#10;        try{&#10;            radius = (strings != null &amp;&amp; strings.length &gt; 0) ? Integer.parseInt(strings[0]) : plugin.getConfig().getInt(&quot;RadiusDefault&quot;);&#10;        } catch (NumberFormatException e) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-invalid&quot;)));&#10;            return true;&#10;        }&#10;        boolean canSearchRadius = radius &lt;= plugin.getConfig().getInt(&quot;RadiusLimit&quot;);&#10;        if(!canSearchRadius){&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-limit&quot;)).replace(&quot;%avlradiuslimit%&quot;, plugin.getConfig().getString(&quot;RadiusLimit&quot;)));&#10;            return true;&#10;        }&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.searching-radius&quot;)).replace(&quot;%avlradius%&quot;, String.valueOf(radius)));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.bulk-unoptimize-start&quot;)));&#10;&#10;        // Counter for unoptimized villagers&#10;        int unoptimizedCount = 0;&#10;&#10;        // Search for nearby villagers&#10;        for (org.bukkit.entity.Entity entity : player.getNearbyEntities(radius, radius, radius)) {&#10;            if (entity instanceof Villager) {&#10;                Villager villager = (Villager) entity;&#10;                //  Setup new Villagers&#10;                if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;                    VillagerUtilities.setAiCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLevelCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLastRestock(villager, plugin);&#10;                    VillagerUtilities.setMarker(villager, plugin, true);&#10;                }&#10;                &#10;                // Only unoptimize if currently optimized&#10;                if (!VillagerUtilities.getMarker(villager, plugin)) {&#10;                    //  Rename villager&#10;                    villager.setCustomName(&quot;&quot;);&#10;                    //  Update the marker and AI&#10;                    VillagerUtilities.setMarker(villager, plugin, true);&#10;                    villager.setAware(true);&#10;                    unoptimizedCount++;&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Send completion message with statistics&#10;        String completeMsg = plugin.getConfig().getString(&quot;messages.bulk-unoptimize-complete&quot;);&#10;        completeMsg = completeMsg.replace(&quot;%avlcount%&quot;, String.valueOf(unoptimizedCount));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(completeMsg));&#10;        &#10;        // Show breeding reminder if villagers were activated&#10;        if (unoptimizedCount &gt; 0) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-breeding-reminder&quot;)));&#10;        }&#10;        return true;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/events/EventListener.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/events/EventListener.java" />
              <option name="originalContent" value="package rebelmythik.antiVillagerLag.events;&#10;&#10;import org.bukkit.ChatColor;&#10;import org.bukkit.Material;&#10;import org.bukkit.entity.*;&#10;import org.bukkit.event.Listener;&#10;import org.bukkit.event.EventHandler;&#10;import org.bukkit.event.entity.EntityDamageByEntityEvent;&#10;import org.bukkit.event.inventory.InventoryClickEvent;&#10;import org.bukkit.event.inventory.InventoryCloseEvent;&#10;import org.bukkit.event.inventory.InventoryType;&#10;import org.bukkit.event.inventory.TradeSelectEvent;&#10;import org.bukkit.event.player.PlayerInteractEntityEvent;&#10;import org.bukkit.event.player.PlayerJoinEvent;&#10;import org.bukkit.inventory.ItemStack;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.UpdateChecker;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class EventListener implements Listener {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;&#10;    public EventListener(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;&#10;    @EventHandler&#10;    public void onRightClick(PlayerInteractEntityEvent event) {&#10;        if (event.isCancelled()) return;&#10;        Player player = event.getPlayer();&#10;        //  It's a villager&#10;        if (!event.getRightClicked().getType().equals(EntityType.VILLAGER)) return;&#10;        Villager villager = (Villager) event.getRightClicked();&#10;&#10;        //  Setup new Villagers&#10;        if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;            VillagerUtilities.setAiCooldown(villager, plugin, 0L);&#10;            VillagerUtilities.setLevelCooldown(villager, plugin, 0L);&#10;            VillagerUtilities.setLastRestock(villager, plugin);&#10;            VillagerUtilities.setMarker(villager, plugin, true);&#10;        }&#10;&#10;        //  Get Times&#10;        long currentTime = System.currentTimeMillis() / 1000;&#10;        long vilLevelCooldown = VillagerUtilities.getLevelCooldown(villager, plugin);&#10;        long vilAiCooldown = VillagerUtilities.getAiCooldown(villager, plugin);&#10;        long totalSeconds = vilAiCooldown - currentTime;&#10;        long sec = totalSeconds % 60;&#10;        long min = totalSeconds / 60;&#10;&#10;        //  If the villager is leveling up&#10;        if (vilLevelCooldown &gt; currentTime) {&#10;            String message = plugin.getConfig().getString(&quot;messages.cooldown-levelup-message&quot;);&#10;            long level_sec = vilLevelCooldown - currentTime;&#10;            message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(level_sec));&#10;            event.getPlayer().sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;            villager.shakeHead();&#10;            event.setCancelled(true);&#10;            return;&#10;        }&#10;&#10;        //  Should it be disabled?&#10;        boolean nametag_result = NameTagAI.call(villager, plugin, player);&#10;        boolean block_result = BlockAI.call(villager, plugin, player);&#10;        boolean workblock_result = WorkblockAI.call(villager, plugin, player);&#10;        boolean should_be_disabled = nametag_result || block_result || workblock_result;&#10;&#10;&#10;        //  If villager AI is being toggled&#10;        if (should_be_disabled == VillagerUtilities.getMarker(villager, plugin)) {&#10;            //  If toggling is on cooldown&#10;            if ((vilAiCooldown &gt; currentTime) &amp;&amp; !player.hasPermission(&quot;avl.cooldown.bypass&quot;)) {&#10;                //Tell player it's on cooldown&#10;                String message = plugin.getConfig().getString(&quot;messages.cooldown-ai-message&quot;);&#10;                message = message.replaceAll(&quot;%avlminutes%&quot;, Long.toString(min));&#10;                message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(sec));&#10;                event.getPlayer().sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;                event.setCancelled(true);&#10;            //  If cooldown is over&#10;            } else {&#10;                VillagerUtilities.setMarker(villager, plugin, !should_be_disabled);&#10;                villager.setAware(!should_be_disabled);&#10;                VillagerUtilities.setAiCooldown(villager, plugin, plugin.getConfig().getLong(&quot;ai-toggle-cooldown&quot;));&#10;                //  If nametag shouldn't be consumed, give one back&#10;                if (player.getInventory().getItemInMainHand().getType().equals(Material.NAME_TAG) &amp;&amp; !plugin.getConfig().getBoolean(&quot;toggleableoptions.usenametags&quot;)) {&#10;                    ItemStack nametag = player.getInventory().getItemInMainHand();&#10;                    if (!nametag.getItemMeta().hasDisplayName()) return;&#10;                    player.getInventory().getItemInMainHand().setAmount(player.getInventory().getItemInMainHand().getAmount() + 1);&#10;                }&#10;            }&#10;        }&#10;        //  If the villager AI is not being toggled&#10;        else {&#10;            //  If nametag shouldn't be consumed, give one back&#10;            if (!VillagerUtilities.hasMarker(villager, plugin)) return;&#10;            if (player.getInventory().getItemInMainHand().getType().equals(Material.NAME_TAG) &amp;&amp; !plugin.getConfig().getBoolean(&quot;toggleableoptions.usenametags&quot;)) {&#10;                ItemStack nametag = player.getInventory().getItemInMainHand();&#10;                if (!nametag.getItemMeta().hasDisplayName()) return;&#10;                player.getInventory().getItemInMainHand().setAmount(player.getInventory().getItemInMainHand().getAmount() + 1);&#10;            }&#10;        }&#10;&#10;        //  Restock&#10;        if (!VillagerUtilities.getMarker(villager, plugin)) {&#10;            RestockVillager.call(villager, plugin, player);&#10;        }&#10;    }&#10;&#10;    // Code for forcing players to disable villagers&#10;&#10;    @EventHandler&#10;    public void inventoryMove(InventoryClickEvent event) {&#10;        if (event.isCancelled()) return;&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.preventtrading&quot;)) return;&#10;        if (!(event.getInventory().getHolder() instanceof Villager)) return;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (!VillagerUtilities.getMarker(vil, plugin)) return;&#10;        Player player = (Player) event.getWhoClicked();&#10;        event.setCancelled(true);&#10;        //player.closeInventory();&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.VillagerMustBeDisabled&quot;)));&#10;    }&#10;&#10;    @EventHandler&#10;    public void villagerTradeClick(TradeSelectEvent event) {&#10;        if (event.isCancelled()) return;&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.preventtrading&quot;)) return;&#10;        if (!(event.getInventory().getHolder() instanceof Villager)) return;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (!VillagerUtilities.getMarker(vil, plugin)) return;&#10;        Player player = (Player) event.getWhoClicked();&#10;        event.setCancelled(true);&#10;        player.closeInventory();&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.VillagerMustBeDisabled&quot;)));&#10;    }&#10;&#10;    // Event to handle cancellation of damage to villagers disable by the plugin&#10;    @EventHandler&#10;    public void onCancelVillagerDamage(EntityDamageByEntityEvent event) {&#10;        if (event.isCancelled()) return;&#10;        if (!(event.getEntity() instanceof Villager &amp;&amp; event.getDamager() instanceof Zombie)) return;&#10;&#10;        Villager vil = (Villager) event.getEntity();&#10;&#10;        if (VillagerUtilities.hasMarker(vil, plugin) &amp;&amp; !VillagerUtilities.getMarker(vil, plugin)) {&#10;            event.setCancelled(true);&#10;        }&#10;    }&#10;&#10;    @EventHandler&#10;    public void playerJoin(PlayerJoinEvent event) {&#10;        if (!event.getPlayer().hasPermission(&quot;avl.notify.update&quot;)) return;&#10;        new UpdateChecker(plugin, 102949).getVersion(version -&gt; {&#10;            if (plugin.getDescription().getVersion().equals(version)) {&#10;                event.getPlayer().sendMessage(ChatColor.GREEN + &quot;AntiVillagerLag is up to date!&quot;);&#10;            } else {&#10;                event.getPlayer().sendMessage(ChatColor.GREEN + &quot;There is an update for AntiVillagerLag! https://www.spigotmc.org/resources/antivillagerlag.102949/&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    // Event to handle Villager updating&#10;    @EventHandler&#10;    public void afterTrade(InventoryCloseEvent event) {&#10;&#10;        Player player = (Player) event.getPlayer();&#10;        if(player.hasPermission(&quot;avl.disable&quot;))&#10;            return;&#10;        // check if inventory belongs to a Villager Trade Screen&#10;        if (event.getInventory().getHolder() == null) return;&#10;        if (event.getInventory().getHolder() instanceof WanderingTrader) return;&#10;        if(event.getInventory().getType() != InventoryType.MERCHANT) return;&#10;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        // make sure the villager is disabled&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (VillagerUtilities.getMarker(vil, plugin)) return;&#10;&#10;        // handle leveling&#10;        VillagerLevelManager.call(vil, plugin, player);&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag.events;&#10;&#10;import org.bukkit.ChatColor;&#10;import org.bukkit.Material;&#10;import org.bukkit.entity.*;&#10;import org.bukkit.event.Listener;&#10;import org.bukkit.event.EventHandler;&#10;import org.bukkit.event.entity.EntityDamageByEntityEvent;&#10;import org.bukkit.event.inventory.InventoryClickEvent;&#10;import org.bukkit.event.inventory.InventoryCloseEvent;&#10;import org.bukkit.event.inventory.InventoryType;&#10;import org.bukkit.event.inventory.TradeSelectEvent;&#10;import org.bukkit.event.player.PlayerInteractEntityEvent;&#10;import org.bukkit.event.player.PlayerJoinEvent;&#10;import org.bukkit.inventory.ItemStack;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.UpdateChecker;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class EventListener implements Listener {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;&#10;    public EventListener(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;&#10;    @EventHandler&#10;    public void onRightClick(PlayerInteractEntityEvent event) {&#10;        if (event.isCancelled()) return;&#10;        Player player = event.getPlayer();&#10;        //  It's a villager&#10;        if (!event.getRightClicked().getType().equals(EntityType.VILLAGER)) return;&#10;        Villager villager = (Villager) event.getRightClicked();&#10;&#10;        //  Setup new Villagers&#10;        if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;            VillagerUtilities.setAiCooldown(villager, plugin, 0L);&#10;            VillagerUtilities.setLevelCooldown(villager, plugin, 0L);&#10;            VillagerUtilities.setLastRestock(villager, plugin);&#10;            VillagerUtilities.setMarker(villager, plugin, true);&#10;        }&#10;&#10;        //  Get Times&#10;        long currentTime = System.currentTimeMillis() / 1000;&#10;        long vilLevelCooldown = VillagerUtilities.getLevelCooldown(villager, plugin);&#10;        long vilAiCooldown = VillagerUtilities.getAiCooldown(villager, plugin);&#10;        long totalSeconds = vilAiCooldown - currentTime;&#10;        long sec = totalSeconds % 60;&#10;        long min = totalSeconds / 60;&#10;&#10;        //  If the villager is leveling up&#10;        if (vilLevelCooldown &gt; currentTime) {&#10;            String message = plugin.getConfig().getString(&quot;messages.cooldown-levelup-message&quot;);&#10;            long level_sec = vilLevelCooldown - currentTime;&#10;            message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(level_sec));&#10;            event.getPlayer().sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;            villager.shakeHead();&#10;            event.setCancelled(true);&#10;            return;&#10;        }&#10;&#10;        //  Should it be disabled?&#10;        boolean nametag_result = NameTagAI.call(villager, plugin, player);&#10;        boolean block_result = BlockAI.call(villager, plugin, player);&#10;        boolean workblock_result = WorkblockAI.call(villager, plugin, player);&#10;        boolean should_be_disabled = nametag_result || block_result || workblock_result;&#10;&#10;&#10;        //  If villager AI is being toggled&#10;        if (should_be_disabled == VillagerUtilities.getMarker(villager, plugin)) {&#10;            //  If toggling is on cooldown&#10;            if ((vilAiCooldown &gt; currentTime) &amp;&amp; !player.hasPermission(&quot;avl.cooldown.bypass&quot;)) {&#10;                //Tell player it's on cooldown&#10;                String message = plugin.getConfig().getString(&quot;messages.cooldown-ai-message&quot;);&#10;                message = message.replaceAll(&quot;%avlminutes%&quot;, Long.toString(min));&#10;                message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(sec));&#10;                event.getPlayer().sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;                event.setCancelled(true);&#10;            //  If cooldown is over&#10;            } else {&#10;                boolean wasOptimized = VillagerUtilities.getMarker(villager, plugin);&#10;                VillagerUtilities.setMarker(villager, plugin, !should_be_disabled);&#10;                villager.setAware(!should_be_disabled);&#10;                VillagerUtilities.setAiCooldown(villager, plugin, plugin.getConfig().getLong(&quot;ai-toggle-cooldown&quot;));&#10;                &#10;                // Enhanced feedback messages&#10;                if (!should_be_disabled) {&#10;                    // Villager was optimized, now being unoptimized (activated)&#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-unoptimized&quot;)));&#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-breeding-reminder&quot;)));&#10;                } else {&#10;                    // Villager was active, now being optimized (disabled)  &#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-optimized&quot;)));&#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-performance-tip&quot;)));&#10;                }&#10;                &#10;                //  If nametag shouldn't be consumed, give one back&#10;                if (player.getInventory().getItemInMainHand().getType().equals(Material.NAME_TAG) &amp;&amp; !plugin.getConfig().getBoolean(&quot;toggleableoptions.usenametags&quot;)) {&#10;                    ItemStack nametag = player.getInventory().getItemInMainHand();&#10;                    if (!nametag.getItemMeta().hasDisplayName()) return;&#10;                    player.getInventory().getItemInMainHand().setAmount(player.getInventory().getItemInMainHand().getAmount() + 1);&#10;                }&#10;            }&#10;        }&#10;        //  If the villager AI is not being toggled&#10;        else {&#10;            // Show current status to player&#10;            if (VillagerUtilities.getMarker(villager, plugin)) {&#10;                // Villager is optimized&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-status-optimized&quot;)));&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-info-optimized&quot;)));&#10;            } else {&#10;                // Villager is active  &#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-status-active&quot;)));&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-info-active&quot;)));&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.action-help&quot;)));&#10;            }&#10;            &#10;            //  If nametag shouldn't be consumed, give one back&#10;            if (!VillagerUtilities.hasMarker(villager, plugin)) return;&#10;            if (player.getInventory().getItemInMainHand().getType().equals(Material.NAME_TAG) &amp;&amp; !plugin.getConfig().getBoolean(&quot;toggleableoptions.usenametags&quot;)) {&#10;                ItemStack nametag = player.getInventory().getItemInMainHand();&#10;                if (!nametag.getItemMeta().hasDisplayName()) return;&#10;                player.getInventory().getItemInMainHand().setAmount(player.getInventory().getItemInMainHand().getAmount() + 1);&#10;            }&#10;        }&#10;&#10;        //  Restock&#10;        if (!VillagerUtilities.getMarker(villager, plugin)) {&#10;            RestockVillager.call(villager, plugin, player);&#10;        }&#10;    }&#10;&#10;    // Code for forcing players to disable villagers&#10;&#10;    @EventHandler&#10;    public void inventoryMove(InventoryClickEvent event) {&#10;        if (event.isCancelled()) return;&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.preventtrading&quot;)) return;&#10;        if (!(event.getInventory().getHolder() instanceof Villager)) return;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (!VillagerUtilities.getMarker(vil, plugin)) return;&#10;        Player player = (Player) event.getWhoClicked();&#10;        event.setCancelled(true);&#10;        //player.closeInventory();&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.VillagerMustBeDisabled&quot;)));&#10;    }&#10;&#10;    @EventHandler&#10;    public void villagerTradeClick(TradeSelectEvent event) {&#10;        if (event.isCancelled()) return;&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.preventtrading&quot;)) return;&#10;        if (!(event.getInventory().getHolder() instanceof Villager)) return;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (!VillagerUtilities.getMarker(vil, plugin)) return;&#10;        Player player = (Player) event.getWhoClicked();&#10;        event.setCancelled(true);&#10;        player.closeInventory();&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.VillagerMustBeDisabled&quot;)));&#10;    }&#10;&#10;    // Event to handle cancellation of damage to villagers disable by the plugin&#10;    @EventHandler&#10;    public void onCancelVillagerDamage(EntityDamageByEntityEvent event) {&#10;        if (event.isCancelled()) return;&#10;        if (!(event.getEntity() instanceof Villager &amp;&amp; event.getDamager() instanceof Zombie)) return;&#10;&#10;        Villager vil = (Villager) event.getEntity();&#10;&#10;        if (VillagerUtilities.hasMarker(vil, plugin) &amp;&amp; !VillagerUtilities.getMarker(vil, plugin)) {&#10;            event.setCancelled(true);&#10;        }&#10;    }&#10;&#10;    @EventHandler&#10;    public void playerJoin(PlayerJoinEvent event) {&#10;        if (!event.getPlayer().hasPermission(&quot;avl.notify.update&quot;)) return;&#10;        new UpdateChecker(plugin, 102949).getVersion(version -&gt; {&#10;            if (plugin.getDescription().getVersion().equals(version)) {&#10;                event.getPlayer().sendMessage(ChatColor.GREEN + &quot;AntiVillagerLag is up to date!&quot;);&#10;            } else {&#10;                event.getPlayer().sendMessage(ChatColor.GREEN + &quot;There is an update for AntiVillagerLag! https://www.spigotmc.org/resources/antivillagerlag.102949/&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    // Event to handle Villager updating&#10;    @EventHandler&#10;    public void afterTrade(InventoryCloseEvent event) {&#10;&#10;        Player player = (Player) event.getPlayer();&#10;        if(player.hasPermission(&quot;avl.disable&quot;))&#10;            return;&#10;        // check if inventory belongs to a Villager Trade Screen&#10;        if (event.getInventory().getHolder() == null) return;&#10;        if (event.getInventory().getHolder() instanceof WanderingTrader) return;&#10;        if(event.getInventory().getType() != InventoryType.MERCHANT) return;&#10;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        // make sure the villager is disabled&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (VillagerUtilities.getMarker(vil, plugin)) return;&#10;&#10;        // handle leveling&#10;        VillagerLevelManager.call(vil, plugin, player);&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/events/RestockVillager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/events/RestockVillager.java" />
              <option name="originalContent" value="package rebelmythik.antiVillagerLag.events;&#10;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class RestockVillager {&#10;&#10;    private static void restockMessage(long timeTillNextRestock, Player player, AntiVillagerLag plugin) {&#10;        long totalsec = timeTillNextRestock / 20;&#10;        long sec = totalsec % 60;&#10;        long min = (totalsec - sec) / 60;&#10;        String message = plugin.getConfig().getString(&quot;messages.next-restock&quot;);&#10;        message = message.replaceAll(&quot;%avlrestockmin%&quot;, Long.toString(min));&#10;        message = message.replaceAll(&quot;%avlrestocksec%&quot;, Long.toString(sec));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;    }&#10;&#10;    public static void call(Villager vil, AntiVillagerLag plugin, Player player) {&#10;&#10;        // Permission to Bypass restock cooldown&#10;        if (player.hasPermission(&quot;avl.restockcooldown.bypass&quot;)) {&#10;            VillagerUtilities.restock(vil);&#10;            VillagerUtilities.setLastRestock(vil, plugin);&#10;            return;&#10;        }&#10;&#10;        // Check if it's time to restock&#10;        long worldTick = vil.getWorld().getFullTime();&#10;        long currentDayTick = vil.getWorld().getTime();&#10;        long beginningOfDayTick = worldTick - currentDayTick;&#10;        long vilTick = VillagerUtilities.getLastRestock(vil, plugin);&#10;&#10;        for (long restockTime : VillagerUtilities.restock_times) {&#10;            long todayRestock = beginningOfDayTick + restockTime;&#10;            if (worldTick &gt;= todayRestock &amp;&amp; vilTick &lt; todayRestock) {&#10;                VillagerUtilities.restock(vil);&#10;                VillagerUtilities.setLastRestock(vil, plugin);&#10;                return;&#10;            }&#10;        }&#10;&#10;        // check if he gets to see cool-down time&#10;        if (player.hasPermission(&quot;avl.message.nextrestock&quot;)) {&#10;            long timeTillNextRestock = Long.MAX_VALUE;&#10;            for (long restockTime : VillagerUtilities.restock_times) {&#10;                long restockTick = beginningOfDayTick + restockTime;&#10;                if (worldTick &lt; restockTick) {&#10;                    timeTillNextRestock = Math.min(timeTillNextRestock, restockTick - worldTick);&#10;                }&#10;            }&#10;&#10;            if (timeTillNextRestock == Long.MAX_VALUE) {&#10;                timeTillNextRestock = (24000 + beginningOfDayTick + VillagerUtilities.restock_times.get(0)) - worldTick;&#10;            }&#10;&#10;            restockMessage(timeTillNextRestock, player, plugin);&#10;        }&#10;    }&#10;&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag.events;&#10;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class RestockVillager {&#10;&#10;    private static void restockMessage(long timeTillNextRestock, Player player, AntiVillagerLag plugin) {&#10;        long totalsec = timeTillNextRestock / 20;&#10;        long sec = totalsec % 60;&#10;        long min = (totalsec - sec) / 60;&#10;        String message = plugin.getConfig().getString(&quot;messages.next-restock&quot;);&#10;        message = message.replaceAll(&quot;%avlrestockmin%&quot;, Long.toString(min));&#10;        message = message.replaceAll(&quot;%avlrestocksec%&quot;, Long.toString(sec));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;    }&#10;&#10;    public static void call(Villager vil, AntiVillagerLag plugin, Player player) {&#10;&#10;        // Permission to Bypass restock cooldown&#10;        if (player.hasPermission(&quot;avl.restockcooldown.bypass&quot;)) {&#10;            VillagerUtilities.restock(vil);&#10;            VillagerUtilities.setLastRestock(vil, plugin);&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-restock-success&quot;)));&#10;            return;&#10;        }&#10;&#10;        // Check if it's time to restock&#10;        long worldTick = vil.getWorld().getFullTime();&#10;        long currentDayTick = vil.getWorld().getTime();&#10;        long beginningOfDayTick = worldTick - currentDayTick;&#10;        long vilTick = VillagerUtilities.getLastRestock(vil, plugin);&#10;&#10;        for (long restockTime : VillagerUtilities.restock_times) {&#10;            long todayRestock = beginningOfDayTick + restockTime;&#10;            if (worldTick &gt;= todayRestock &amp;&amp; vilTick &lt; todayRestock) {&#10;                VillagerUtilities.restock(vil);&#10;                VillagerUtilities.setLastRestock(vil, plugin);&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-restock-success&quot;)));&#10;                return;&#10;            }&#10;        }&#10;&#10;        // check if he gets to see cool-down time&#10;        if (player.hasPermission(&quot;avl.message.nextrestock&quot;)) {&#10;            long timeTillNextRestock = Long.MAX_VALUE;&#10;            for (long restockTime : VillagerUtilities.restock_times) {&#10;                long restockTick = beginningOfDayTick + restockTime;&#10;                if (worldTick &lt; restockTick) {&#10;                    timeTillNextRestock = Math.min(timeTillNextRestock, restockTick - worldTick);&#10;                }&#10;            }&#10;&#10;            if (timeTillNextRestock == Long.MAX_VALUE) {&#10;                timeTillNextRestock = (24000 + beginningOfDayTick + VillagerUtilities.restock_times.get(0)) - worldTick;&#10;            }&#10;&#10;            restockMessage(timeTillNextRestock, player, plugin);&#10;        }&#10;    }&#10;&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/events/VillagerLevelManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/events/VillagerLevelManager.java" />
              <option name="originalContent" value="package rebelmythik.antiVillagerLag.events;&#10;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import org.bukkit.potion.PotionEffect;&#10;import org.bukkit.potion.PotionEffectType;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.CalculateLevel;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class VillagerLevelManager {&#10;&#10;    public static void call(Villager vil, AntiVillagerLag plugin, Player player) {&#10;        int cooldown = 5;&#10;        int vilLevel = vil.getVillagerLevel();&#10;        long newLevel = CalculateLevel.villagerEXP(vil);&#10;        long currentTime = System.currentTimeMillis() / 1000;&#10;&#10;        long vilLevelCooldown = VillagerUtilities.getLevelCooldown(vil, plugin);&#10;        long totalSeconds = vilLevelCooldown - currentTime;&#10;        long sec = totalSeconds % 60;&#10;&#10;        if (vilLevelCooldown &gt; currentTime) {&#10;            String message = plugin.getConfig().getString(&quot;messages.cooldown-levelup-message&quot;);&#10;            message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(sec));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;            return;&#10;        }&#10;&#10;        if (vilLevel &lt; newLevel) {&#10;            VillagerUtilities.setLevelCooldown(vil, plugin, cooldown);&#10;            // make villager immovable while AI is disabled&#10;            vil.addPotionEffect(new PotionEffect(PotionEffectType.SLOW, (int)(cooldown * 20)+20, 120, false, false));&#10;            vil.setAware(true);&#10;        } else return;&#10;&#10;        Bukkit.getScheduler().scheduleSyncDelayedTask(plugin, () -&gt; {&#10;            vil.setAware(false);&#10;        }, 100L);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag.events;&#10;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import org.bukkit.potion.PotionEffect;&#10;import org.bukkit.potion.PotionEffectType;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.CalculateLevel;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class VillagerLevelManager {&#10;&#10;    public static void call(Villager vil, AntiVillagerLag plugin, Player player) {&#10;        int cooldown = 5;&#10;        int vilLevel = vil.getVillagerLevel();&#10;        long newLevel = CalculateLevel.villagerEXP(vil);&#10;        long currentTime = System.currentTimeMillis() / 1000;&#10;&#10;        long vilLevelCooldown = VillagerUtilities.getLevelCooldown(vil, plugin);&#10;        long totalSeconds = vilLevelCooldown - currentTime;&#10;        long sec = totalSeconds % 60;&#10;&#10;        if (vilLevelCooldown &gt; currentTime) {&#10;            String message = plugin.getConfig().getString(&quot;messages.cooldown-levelup-message&quot;);&#10;            message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(sec));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;            return;&#10;        }&#10;&#10;        if (vilLevel &lt; newLevel) {&#10;            VillagerUtilities.setLevelCooldown(vil, plugin, cooldown);&#10;            // Notify player that villager is leveling up&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-levelup-starting&quot;)));&#10;            // make villager immovable while AI is disabled&#10;            vil.addPotionEffect(new PotionEffect(PotionEffectType.SLOW, (int)(cooldown * 20)+20, 120, false, false));&#10;            vil.setAware(true);&#10;        } else return;&#10;&#10;        Bukkit.getScheduler().scheduleSyncDelayedTask(plugin, () -&gt; {&#10;            vil.setAware(false);&#10;            // Notify player that level up is complete&#10;            if (player.isOnline()) {&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-levelup-complete&quot;)));&#10;            }&#10;        }, 100L);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/config.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/config.yml" />
              <option name="updatedContent" value="# These names will cause the villager to be disabled when named with a nametag&#10;NamesThatDisable:&#10;  - Optimize&#10;  - Bonk&#10;&#10;# This needs to be a valid block ID to work.&#10;BlocksThatDisable:&#10;  - EMERALD_BLOCK&#10;  - DIAMOND_BLOCK&#10;&#10;# List of workstations that will disable mobs&#10;WorkstationsThatDisable:&#10;  - COMPOSTER&#10;  - SMOKER&#10;  - BARREL&#10;  - LOOM&#10;  - BLAST_FURNACE&#10;  - BREWING_STAND&#10;  - Cauldron&#10;  - FLETCHING_TABLE&#10;  - CARTOGRAPHY_TABLE&#10;  - LECTERN&#10;  - SMITHING_TABLE&#10;  - STONECUTTER&#10;  - GRINDSTONE&#10;&#10;# Please do the time in ticks or it will break the plugin. There is 24,000 ticks in a single day.&#10;# See https://minecraft.fandom.com/wiki/Daylight_cycle for more info&#10;RestockTimes:&#10;  times:&#10;    - 1000&#10;    - 13000&#10;&#10;# This time is in seconds. This cooldown is to prevent possible abuse&#10;# of people repeatedly disabling ai and re-enabling it to get double trades. I would keep this&#10;# at the minimum time of 10 minutes or 600 seconds due anything less allowing for the double trades to happen.&#10;ai-toggle-cooldown: 600&#10;&#10;# The maximum radius in blocks the /avloptimize command can search&#10;RadiusLimit: 50&#10;&#10;# the default radius for /avloptimize when no argument is specified&#10;RadiusDefault: 50&#10;&#10;toggleableoptions:&#10;  # Prevent trading with villagers when they aren't disabled. Still allows players to preview trades&#10;  preventtrading: true&#10;&#10;  # If set to true, nametags will be used instead of being infinite.&#10;  usenametags: false&#10;&#10;  # One of these following options needs to be true for the plugin to work.&#10;  ### This will allow nametags to disable and renable the Villager AI. This also effects the /avloptimize command&#10;  userenaming: true&#10;&#10;  ### This will allow a block to disable and renable the Villager AI.&#10;  useblocks: false&#10;&#10;  ### This feature will disable the villager if they have a workstation in the configurable radius in blocks of the villager&#10;  useworkstations: false&#10;  workstationcheckradius: 2&#10;&#10;messages:&#10;  no-permission: &quot;&amp;cYou don't have permission to use this command.&quot;&#10;  reload-message: &quot;&amp;aPlugin successfully reloaded.&quot;&#10;  cooldown-ai-message: &quot;&amp;cYou can toggle this villager's AI again in %avlminutes% minutes and %avlseconds% seconds.&quot;&#10;  cooldown-levelup-message: &quot;&amp;cThe villager is currently leveling up! You can use the villager again in %avlseconds% seconds.&quot;&#10;  next-restock: &quot;&amp;cThe next restock for the villager will be in %avlrestockmin% minutes and %avlrestocksec% seconds.&quot;&#10;  optimize-command-usage: &quot;&amp;cCorrect Usage is /avloptimize &lt;radius&gt;&quot;&#10;  unoptimize-command-usage: &quot;&amp;cCorrect Usage is /avlunoptimize &lt;radius&gt;&quot;&#10;  radius-limit: &quot;&amp;cThe radius you tried is too big. Radius limit is %avlradiuslimit% blocks.&quot;&#10;  VillagerMustBeDisabled: &quot;&amp;cYou need to disable the villager before you can trade with it&quot;&#10;  searching-radius: &quot;&amp;aSearching radius of %avlradius% blocks.&quot;&#10;  radius-invalid: &quot;&amp;cRadius must be a valid Integer.&quot;&#10;  &#10;  # Enhanced feedback messages for better player experience&#10;  villager-optimized: &quot;&amp;a✓ Villager AI disabled! This villager is now optimized and consuming minimal server resources.&quot;&#10;  villager-unoptimized: &quot;&amp;e⚠ Villager AI enabled! This villager is now active and can move/breed.&quot;&#10;  villager-already-optimized: &quot;&amp;7This villager is already optimized (AI disabled).&quot;&#10;  villager-already-unoptimized: &quot;&amp;7This villager is already active (AI enabled).&quot;&#10;  villager-status-optimized: &quot;&amp;a[OPTIMIZED] &amp;7This villager's AI is disabled - ready for trading!&quot;&#10;  villager-status-active: &quot;&amp;e[ACTIVE] &amp;7This villager's AI is enabled - can move and breed.&quot;&#10;  villager-performance-tip: &quot;&amp;6 Tip: Keep villagers optimized when not breeding to improve server performance!&quot;&#10;  villager-breeding-reminder: &quot;&amp;6 Reminder: Unoptimize villagers temporarily if you need them to breed.&quot;&#10;  villager-zombie-protected: &quot;&amp;a This optimized villager is protected from zombie attacks!&quot;&#10;  villager-restock-success: &quot;&amp;a✅ Villager restocked successfully!&quot;&#10;  villager-levelup-starting: &quot;&amp;e⚡ Villager is leveling up... AI temporarily enabled.&quot;&#10;  villager-levelup-complete: &quot;&amp;a✅ Villager level up complete! AI optimization restored.&quot;&#10;  bulk-optimize-start: &quot;&amp;aStarting bulk optimization of villagers...&quot;&#10;  bulk-optimize-complete: &quot;&amp;a✅ Bulk optimization complete! &amp;7%avlcount% villagers optimized.&quot;&#10;  bulk-unoptimize-start: &quot;&amp;eStarting bulk unoptimization of villagers...&quot;&#10;  bulk-unoptimize-complete: &quot;&amp;e✅ Bulk unoptimization complete! &amp;7%avlcount% villagers activated.&quot;&#10;  performance-impact: &quot;&amp;a Performance Impact: &amp;7-%avlpercentage%% server load from optimized villagers.&quot;&#10;  action-help: &quot;&amp;6ℹ Right-click with 'Optimize' nametag to disable AI, or rename to anything else to enable AI.&quot;&#10;  villager-info-optimized: &quot;&amp;a[OPTIMIZED] &amp;7Status: Frozen, Trading: Available, Breeding: Disabled&quot;&#10;  villager-info-active: &quot;&amp;e[ACTIVE] &amp;7Status: Mobile, Trading: Restricted, Breeding: Enabled&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>