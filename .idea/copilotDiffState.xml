<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/events/WorkblockAI.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/events/WorkblockAI.java" />
              <option name="originalContent" value="package loyfael.antiVillagerLag.events;&#10;&#10;import org.bukkit.Location;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import loyfael.antiVillagerLag.AntiVillagerLag;&#10;import loyfael.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class WorkblockAI {&#10;&#10;    public static boolean call(Villager villager, AntiVillagerLag plugin, Player player) {&#10;        //check if workstation is disabled&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.useworkstations&quot;)) return false;&#10;&#10;        int radius = plugin.getConfig().getInt(&quot;toggleableoptions.workstationcheckradius&quot;);&#10;        // Check for blocks within the specified radius&#10;        for (int x = -radius; x &lt;= radius; x++) {&#10;            for (int y = -radius; y &lt;= radius; y++) {&#10;                for (int z = -radius; z &lt;= radius; z++) {&#10;                    Location blockLocation = new Location(villager.getWorld(), villager.getLocation().getX() + x, villager.getLocation().getY() + y, villager.getLocation().getZ() + z);&#10;                    if (VillagerUtilities.standingon_blocks.contains(blockLocation.getBlock().getType())) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package loyfael.antiVillagerLag.events;&#10;&#10;import org.bukkit.Location;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import loyfael.antiVillagerLag.AntiVillagerLag;&#10;import loyfael.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class WorkblockAI {&#10;&#10;    public static boolean call(Villager villager, AntiVillagerLag plugin, Player player) {&#10;        //check if workstation is disabled&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.useworkstations&quot;)) return false;&#10;&#10;        int radius = plugin.getConfig().getInt(&quot;toggleableoptions.workstationcheckradius&quot;);&#10;        // Check for blocks within the specified radius&#10;        for (int x = -radius; x &lt;= radius; x++) {&#10;            for (int y = -radius; y &lt;= radius; y++) {&#10;                for (int z = -radius; z &lt;= radius; z++) {&#10;                    Location blockLocation = new Location(villager.getWorld(), villager.getLocation().getX() + x, villager.getLocation().getY() + y, villager.getLocation().getZ() + z);&#10;                    if (VillagerUtilities.standingon_blocks.contains(blockLocation.getBlock().getType())) {&#10;                        return true;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/utils/ActionBarUtils.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/loyfael/antiVillagerLag/utils/ActionBarUtils.java" />
              <option name="updatedContent" value="package loyfael.antiVillagerLag.utils;&#10;&#10;import net.md_5.bungee.api.ChatMessageType;&#10;import net.md_5.bungee.api.chat.TextComponent;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import loyfael.antiVillagerLag.AntiVillagerLag;&#10;&#10;public class ActionBarUtils {&#10;&#10;    public static void sendVillagerStatus(Player player, Villager villager, AntiVillagerLag plugin) {&#10;        if (!plugin.getConfig().getBoolean(&quot;action-bar.enabled&quot;, true)) return;&#10;        &#10;        String message;&#10;        if (VillagerUtilities.hasMarker(villager, plugin)) {&#10;            if (VillagerUtilities.getMarker(villager, plugin)) {&#10;                // Villager is optimized (AI disabled)&#10;                message = plugin.getConfig().getString(&quot;action-bar.status-optimized&quot;, &quot;&amp;a[OPTIMIZED] &amp;7Ready for trading&quot;);&#10;            } else {&#10;                // Villager is active (AI enabled)&#10;                message = plugin.getConfig().getString(&quot;action-bar.status-active&quot;, &quot;&amp;e[ACTIVE] &amp;7Mobile villager&quot;);&#10;            }&#10;        } else {&#10;            message = plugin.getConfig().getString(&quot;action-bar.status-new&quot;, &quot;&amp;7[NEW] &amp;eRight-click to setup&quot;);&#10;        }&#10;        &#10;        message = VillagerUtilities.colorcodes.cm(message);&#10;        player.spigot().sendMessage(ChatMessageType.ACTION_BAR, new TextComponent(message));&#10;    }&#10;    &#10;    public static void sendCooldownInfo(Player player, long minutes, long seconds, AntiVillagerLag plugin) {&#10;        if (!plugin.getConfig().getBoolean(&quot;action-bar.enabled&quot;, true)) return;&#10;        &#10;        String message = plugin.getConfig().getString(&quot;action-bar.cooldown&quot;, &quot;&amp;c⏰ Cooldown: %avlminutes%m %avlseconds%s&quot;);&#10;        message = message.replaceAll(&quot;%avlminutes%&quot;, String.valueOf(minutes));&#10;        message = message.replaceAll(&quot;%avlseconds%&quot;, String.valueOf(seconds));&#10;        message = VillagerUtilities.colorcodes.cm(message);&#10;        &#10;        player.spigot().sendMessage(ChatMessageType.ACTION_BAR, new TextComponent(message));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/AntiVillagerLag.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/AntiVillagerLag.java" />
              <option name="originalContent" value="package rebelmythik.antiVillagerLag;&#10;&#10;import org.bstats.bukkit.Metrics;&#10;import org.bstats.charts.MultiLineChart;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.ChatColor;&#10;import org.bukkit.configuration.Configuration;&#10;import org.bukkit.configuration.InvalidConfigurationException;&#10;import org.bukkit.configuration.file.YamlConfiguration;&#10;import org.bukkit.plugin.java.JavaPlugin;&#10;import rebelmythik.antiVillagerLag.commands.OptimizeCommand;&#10;import rebelmythik.antiVillagerLag.commands.ReloadCommand;&#10;import rebelmythik.antiVillagerLag.commands.RemoveChangesCommand;&#10;import rebelmythik.antiVillagerLag.commands.UnoptimizeCommand;&#10;import rebelmythik.antiVillagerLag.events.EventListener;&#10;import rebelmythik.antiVillagerLag.utils.UpdateChecker;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;import java.io.File;&#10;import java.io.IOException;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public final class AntiVillagerLag extends JavaPlugin {&#10;&#10;    @Override&#10;    public void onEnable() {&#10;&#10;        //  Command Registration&#10;        getCommand(&quot;avlreload&quot;).setExecutor(new ReloadCommand(this));&#10;        getCommand(&quot;avloptimize&quot;).setExecutor(new OptimizeCommand(this));&#10;        getCommand(&quot;avlunoptimize&quot;).setExecutor(new UnoptimizeCommand(this));&#10;        getCommand(&quot;avlremove&quot;).setExecutor(new RemoveChangesCommand(this));&#10;&#10;        //  Event Registration&#10;        getServer().getPluginManager().registerEvents(new EventListener(this), this);&#10;&#10;&#10;        //  Config Stuff&#10;        saveDefaultConfig();&#10;        updateConfig();&#10;&#10;        VillagerUtilities.updateNameTags(this);&#10;        VillagerUtilities.updateStandingOnBlocks(this);&#10;        VillagerUtilities.updateWorkstationBlocks(this);&#10;        VillagerUtilities.updateRestockTimes(this);&#10;&#10;        //  Bstats Code&#10;        int pluginId = 15890;&#10;        Metrics metrics = new Metrics(this, pluginId);&#10;        //  Optional: Add custom charts&#10;        metrics.addCustomChart(new MultiLineChart(&quot;players_and_servers&quot;, () -&gt; {&#10;            Map&lt;String, Integer&gt; valueMap = new HashMap&lt;&gt;();&#10;            valueMap.put(&quot;servers&quot;, 1);&#10;            valueMap.put(&quot;players&quot;, Bukkit.getOnlinePlayers().size());&#10;            return valueMap;&#10;        }));&#10;&#10;        //  Check for plugin updates&#10;        new UpdateChecker(this, 102949).getVersion(version -&gt; {&#10;            if (this.getDescription().getVersion().equals(version)) {&#10;                getLogger().info(&quot;AntiVillagerLag is up to date!&quot;);&#10;            } else {&#10;                getLogger().info(&quot;There is an update for AntiVillagerLag! https://www.spigotmc.org/resources/antivillagerlag.102949/&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void onDisable() {&#10;        //  Plugin shutdown logic&#10;    }&#10;&#10;    //  Configuration File Updater&#10;    public Configuration cfg = this.getConfig().getDefaults();&#10;    public void updateConfig() {&#10;        try {&#10;            if(new File(getDataFolder() + &quot;/config.yml&quot;).exists()) {&#10;                boolean changesMade = false;&#10;                YamlConfiguration tmp = new YamlConfiguration();&#10;                tmp.load(getDataFolder() + &quot;/config.yml&quot;);&#10;                for(String str : cfg.getKeys(true)) {&#10;                    if(!tmp.getKeys(true).contains(str)) {&#10;                        tmp.set(str, cfg.get(str));&#10;                        changesMade = true;&#10;                    }&#10;                }&#10;                if(changesMade)&#10;                    tmp.save(getDataFolder() + &quot;/config.yml&quot;);&#10;            }&#10;        } catch (IOException | InvalidConfigurationException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag;&#10;&#10;import org.bstats.bukkit.Metrics;&#10;import org.bstats.charts.MultiLineChart;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.ChatColor;&#10;import org.bukkit.configuration.Configuration;&#10;import org.bukkit.configuration.InvalidConfigurationException;&#10;import org.bukkit.configuration.file.YamlConfiguration;&#10;import org.bukkit.plugin.java.JavaPlugin;&#10;import rebelmythik.antiVillagerLag.commands.OptimizeCommand;&#10;import rebelmythik.antiVillagerLag.commands.ReloadCommand;&#10;import rebelmythik.antiVillagerLag.commands.RemoveChangesCommand;&#10;import rebelmythik.antiVillagerLag.commands.UnoptimizeCommand;&#10;import rebelmythik.antiVillagerLag.commands.StatusCommand;&#10;import rebelmythik.antiVillagerLag.events.EventListener;&#10;import rebelmythik.antiVillagerLag.utils.UpdateChecker;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;import java.io.File;&#10;import java.io.IOException;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public final class AntiVillagerLag extends JavaPlugin {&#10;&#10;    @Override&#10;    public void onEnable() {&#10;&#10;        //  Command Registration&#10;        getCommand(&quot;avlreload&quot;).setExecutor(new ReloadCommand(this));&#10;        getCommand(&quot;avloptimize&quot;).setExecutor(new OptimizeCommand(this));&#10;        getCommand(&quot;avlunoptimize&quot;).setExecutor(new UnoptimizeCommand(this));&#10;        getCommand(&quot;avlremove&quot;).setExecutor(new RemoveChangesCommand(this));&#10;        getCommand(&quot;avlstatus&quot;).setExecutor(new StatusCommand(this));&#10;&#10;        //  Event Registration&#10;        getServer().getPluginManager().registerEvents(new EventListener(this), this);&#10;&#10;&#10;        //  Config Stuff&#10;        saveDefaultConfig();&#10;        updateConfig();&#10;&#10;        VillagerUtilities.updateNameTags(this);&#10;        VillagerUtilities.updateStandingOnBlocks(this);&#10;        VillagerUtilities.updateWorkstationBlocks(this);&#10;        VillagerUtilities.updateRestockTimes(this);&#10;&#10;        //  Bstats Code&#10;        int pluginId = 15890;&#10;        Metrics metrics = new Metrics(this, pluginId);&#10;        //  Optional: Add custom charts&#10;        metrics.addCustomChart(new MultiLineChart(&quot;players_and_servers&quot;, () -&gt; {&#10;            Map&lt;String, Integer&gt; valueMap = new HashMap&lt;&gt;();&#10;            valueMap.put(&quot;servers&quot;, 1);&#10;            valueMap.put(&quot;players&quot;, Bukkit.getOnlinePlayers().size());&#10;            return valueMap;&#10;        }));&#10;&#10;        //  Check for plugin updates&#10;        new UpdateChecker(this, 102949).getVersion(version -&gt; {&#10;            if (this.getDescription().getVersion().equals(version)) {&#10;                getLogger().info(&quot;AntiVillagerLag is up to date!&quot;);&#10;            } else {&#10;                getLogger().info(&quot;There is an update for AntiVillagerLag! https://www.spigotmc.org/resources/antivillagerlag.102949/&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    @Override&#10;    public void onDisable() {&#10;        //  Plugin shutdown logic&#10;    }&#10;&#10;    //  Configuration File Updater&#10;    public Configuration cfg = this.getConfig().getDefaults();&#10;    public void updateConfig() {&#10;        try {&#10;            if(new File(getDataFolder() + &quot;/config.yml&quot;).exists()) {&#10;                boolean changesMade = false;&#10;                YamlConfiguration tmp = new YamlConfiguration();&#10;                tmp.load(getDataFolder() + &quot;/config.yml&quot;);&#10;                for(String str : cfg.getKeys(true)) {&#10;                    if(!tmp.getKeys(true).contains(str)) {&#10;                        tmp.set(str, cfg.get(str));&#10;                        changesMade = true;&#10;                    }&#10;                }&#10;                if(changesMade)&#10;                    tmp.save(getDataFolder() + &quot;/config.yml&quot;);&#10;            }&#10;        } catch (IOException | InvalidConfigurationException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/commands/OptimizeCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/commands/OptimizeCommand.java" />
              <option name="originalContent" value="package rebelmythik.antiVillagerLag.commands;&#10;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.entity.Entity;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.events.BlockAI;&#10;import rebelmythik.antiVillagerLag.events.NameTagAI;&#10;import rebelmythik.antiVillagerLag.events.WorkblockAI;&#10;import rebelmythik.antiVillagerLag.utils.ColorCode;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class OptimizeCommand implements CommandExecutor {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;    public OptimizeCommand(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender commandSender, Command command, String s, String[] strings) {&#10;        if (!command.getName().equalsIgnoreCase(&quot;avloptimize&quot;)) return true;&#10;        //  Make sure it's a player&#10;        if (!(commandSender instanceof Player)) return false;&#10;        Player player = (Player) commandSender;&#10;&#10;        //  Check if they have permission&#10;        if(!player.hasPermission(&quot;avl.optimize&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.no-permission&quot;)));&#10;            return true;&#10;        }&#10;&#10;        //searchable radius based on first argument specified, if null defaults to config&#10;        int radius;&#10;        try{&#10;            radius = (strings != null &amp;&amp; strings.length &gt; 0) ? Integer.parseInt(strings[0]) : plugin.getConfig().getInt(&quot;RadiusDefault&quot;);&#10;        } catch (NumberFormatException e) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-invalid&quot;)));&#10;            return true;&#10;        }&#10;        boolean canSearchRadius = radius &lt;= plugin.getConfig().getInt(&quot;RadiusLimit&quot;);&#10;        if(!canSearchRadius){&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-limit&quot;)).replace(&quot;%avlradiuslimit%&quot;, plugin.getConfig().getString(&quot;RadiusLimit&quot;)));&#10;            return true;&#10;        }&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.searching-radius&quot;)).replace(&quot;%avlradius%&quot;, String.valueOf(radius)));&#10;&#10;        // Search for nearby villagers&#10;        player.getNearbyEntities(radius, radius, radius).forEach(entity -&gt; {&#10;            if (entity instanceof Villager) {&#10;                Villager villager = (Villager) entity;&#10;                //  Setup new Villagers&#10;                if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;                    VillagerUtilities.setAiCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLevelCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLastRestock(villager, plugin);&#10;                    VillagerUtilities.setMarker(villager, plugin, true);&#10;                }&#10;                //  Rename villager&#10;                villager.setCustomName(VillagerUtilities.disabling_names.getFirst());&#10;                //  Update the marker and AI&#10;                VillagerUtilities.setMarker(villager, plugin, false);&#10;                villager.setAware(false);&#10;&#10;            }&#10;        });&#10;        return true;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag.commands;&#10;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.entity.Entity;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.events.BlockAI;&#10;import rebelmythik.antiVillagerLag.events.NameTagAI;&#10;import rebelmythik.antiVillagerLag.events.WorkblockAI;&#10;import rebelmythik.antiVillagerLag.utils.ColorCode;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class OptimizeCommand implements CommandExecutor {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;    public OptimizeCommand(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender commandSender, Command command, String s, String[] strings) {&#10;        if (!command.getName().equalsIgnoreCase(&quot;avloptimize&quot;)) return true;&#10;        //  Make sure it's a player&#10;        if (!(commandSender instanceof Player)) return false;&#10;        Player player = (Player) commandSender;&#10;&#10;        //  Check if they have permission&#10;        if(!player.hasPermission(&quot;avl.optimize&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.no-permission&quot;)));&#10;            return true;&#10;        }&#10;&#10;        //searchable radius based on first argument specified, if null defaults to config&#10;        int radius;&#10;        try{&#10;            radius = (strings != null &amp;&amp; strings.length &gt; 0) ? Integer.parseInt(strings[0]) : plugin.getConfig().getInt(&quot;RadiusDefault&quot;);&#10;        } catch (NumberFormatException e) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-invalid&quot;)));&#10;            return true;&#10;        }&#10;        boolean canSearchRadius = radius &lt;= plugin.getConfig().getInt(&quot;RadiusLimit&quot;);&#10;        if(!canSearchRadius){&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-limit&quot;)).replace(&quot;%avlradiuslimit%&quot;, plugin.getConfig().getString(&quot;RadiusLimit&quot;)));&#10;            return true;&#10;        }&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.searching-radius&quot;)).replace(&quot;%avlradius%&quot;, String.valueOf(radius)));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.bulk-optimize-start&quot;)));&#10;&#10;        // Counter for optimized villagers&#10;        int optimizedCount = 0;&#10;&#10;        // Search for nearby villagers&#10;        for (Entity entity : player.getNearbyEntities(radius, radius, radius)) {&#10;            if (entity instanceof Villager) {&#10;                Villager villager = (Villager) entity;&#10;                //  Setup new Villagers&#10;                if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;                    VillagerUtilities.setAiCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLevelCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLastRestock(villager, plugin);&#10;                    VillagerUtilities.setMarker(villager, plugin, true);&#10;                }&#10;                &#10;                // Only optimize if not already optimized&#10;                if (VillagerUtilities.getMarker(villager, plugin)) {&#10;                    //  Rename villager&#10;                    villager.setCustomName(VillagerUtilities.disabling_names.getFirst());&#10;                    //  Update the marker and AI&#10;                    VillagerUtilities.setMarker(villager, plugin, false);&#10;                    villager.setAware(false);&#10;                    optimizedCount++;&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Send completion message with statistics&#10;        String completeMsg = plugin.getConfig().getString(&quot;messages.bulk-optimize-complete&quot;);&#10;        completeMsg = completeMsg.replace(&quot;%avlcount%&quot;, String.valueOf(optimizedCount));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(completeMsg));&#10;        &#10;        // Calculate and show performance impact&#10;        if (optimizedCount &gt; 0) {&#10;            int estimatedPerformanceGain = Math.min(90, optimizedCount * 2); // Rough estimate: 2% per villager, max 90%&#10;            String performanceMsg = plugin.getConfig().getString(&quot;messages.performance-impact&quot;);&#10;            performanceMsg = performanceMsg.replace(&quot;%avlpercentage%&quot;, String.valueOf(estimatedPerformanceGain));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(performanceMsg));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-zombie-protected&quot;)));&#10;        }&#10;        return true;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/commands/StatusCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/commands/StatusCommand.java" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag.commands;&#10;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.entity.Entity;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class StatusCommand implements CommandExecutor {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;    public StatusCommand(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender commandSender, Command command, String s, String[] strings) {&#10;        if (!command.getName().equalsIgnoreCase(&quot;avlstatus&quot;)) return true;&#10;        &#10;        // Make sure it's a player&#10;        if (!(commandSender instanceof Player)) return false;&#10;        Player player = (Player) commandSender;&#10;&#10;        // Check if they have permission&#10;        if(!player.hasPermission(&quot;avl.status&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.no-permission&quot;)));&#10;            return true;&#10;        }&#10;&#10;        // Default radius or specified radius&#10;        int radius;&#10;        try{&#10;            radius = (strings != null &amp;&amp; strings.length &gt; 0) ? Integer.parseInt(strings[0]) : plugin.getConfig().getInt(&quot;RadiusDefault&quot;);&#10;        } catch (NumberFormatException e) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-invalid&quot;)));&#10;            return true;&#10;        }&#10;&#10;        boolean canSearchRadius = radius &lt;= plugin.getConfig().getInt(&quot;RadiusLimit&quot;);&#10;        if(!canSearchRadius){&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-limit&quot;)).replace(&quot;%avlradiuslimit%&quot;, plugin.getConfig().getString(&quot;RadiusLimit&quot;)));&#10;            return true;&#10;        }&#10;&#10;        // Count villagers&#10;        int totalVillagers = 0;&#10;        int optimizedVillagers = 0;&#10;        int activeVillagers = 0;&#10;        int unmanagedVillagers = 0;&#10;&#10;        // Search for nearby villagers&#10;        for (Entity entity : player.getNearbyEntities(radius, radius, radius)) {&#10;            if (entity instanceof Villager) {&#10;                Villager villager = (Villager) entity;&#10;                totalVillagers++;&#10;&#10;                if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;                    unmanagedVillagers++;&#10;                } else if (!VillagerUtilities.getMarker(villager, plugin)) {&#10;                    optimizedVillagers++;&#10;                } else {&#10;                    activeVillagers++;&#10;                }&#10;            }&#10;        }&#10;&#10;        // Send status report&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;6━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;6            AntiVillagerLag Status Report&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;6━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;e Search Radius: &amp;7&quot; + radius + &quot; blocks&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;f Total Villagers Found: &amp;b&quot; + totalVillagers));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;a✅ Optimized (Frozen): &amp;2&quot; + optimizedVillagers));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;e⚡ Active (Mobile): &amp;6&quot; + activeVillagers));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;7❓ Unmanaged: &amp;8&quot; + unmanagedVillagers));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&quot;));&#10;        &#10;        if (totalVillagers &gt; 0) {&#10;            int optimizationRate = (optimizedVillagers * 100) / totalVillagers;&#10;            int estimatedPerformanceGain = Math.min(90, optimizedVillagers * 2);&#10;            &#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;f Optimization Rate: &amp;b&quot; + optimizationRate + &quot;%&quot;));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;f Estimated Performance Gain: &amp;a~&quot; + estimatedPerformanceGain + &quot;%&quot;));&#10;            &#10;            if (optimizationRate &lt; 70) {&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;c⚠ Consider optimizing more villagers for better performance!&quot;));&#10;            } else if (optimizationRate &gt;= 70 &amp;&amp; optimizationRate &lt; 90) {&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;e Good optimization level!&quot;));&#10;            } else {&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;a Excellent optimization! Great job!&quot;));&#10;            }&#10;        }&#10;        &#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;7 Use &amp;f/avloptimize &quot; + radius + &quot;&amp;7 to optimize all villagers&quot;));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(&quot;&amp;6━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━&quot;));&#10;&#10;        return true;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/commands/UnoptimizeCommand.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/commands/UnoptimizeCommand.java" />
              <option name="originalContent" value="package rebelmythik.antiVillagerLag.commands;&#10;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class UnoptimizeCommand implements CommandExecutor {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;    public UnoptimizeCommand(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender commandSender, Command command, String s, String[] strings) {&#10;        if (!command.getName().equalsIgnoreCase(&quot;avlunoptimize&quot;)) return true;&#10;        //  Make sure it's a player&#10;        if (!(commandSender instanceof Player)) return false;&#10;        Player player = (Player) commandSender;&#10;&#10;        //  Check if they have permission&#10;        if(!player.hasPermission(&quot;avl.unoptimize&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.no-permission&quot;)));&#10;            return true;&#10;        }&#10;&#10;        //searchable radius based on first argument specified, if null defaults to config&#10;        int radius;&#10;        try{&#10;            radius = (strings != null &amp;&amp; strings.length &gt; 0) ? Integer.parseInt(strings[0]) : plugin.getConfig().getInt(&quot;RadiusDefault&quot;);&#10;        } catch (NumberFormatException e) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-invalid&quot;)));&#10;            return true;&#10;        }&#10;        boolean canSearchRadius = radius &lt;= plugin.getConfig().getInt(&quot;RadiusLimit&quot;);&#10;        if(!canSearchRadius){&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-limit&quot;)).replace(&quot;%avlradiuslimit%&quot;, plugin.getConfig().getString(&quot;RadiusLimit&quot;)));&#10;            return true;&#10;        }&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.searching-radius&quot;)).replace(&quot;%avlradius%&quot;, String.valueOf(radius)));&#10;&#10;        // Search for nearby villagers&#10;        player.getNearbyEntities(radius, radius, radius).forEach(entity -&gt; {&#10;            if (entity instanceof Villager) {&#10;                Villager villager = (Villager) entity;&#10;                //  Setup new Villagers&#10;                if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;                    VillagerUtilities.setAiCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLevelCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLastRestock(villager, plugin);&#10;                    VillagerUtilities.setMarker(villager, plugin, true);&#10;                }&#10;                //  Rename villager&#10;                villager.setCustomName(&quot;&quot;);&#10;                //  Update the marker and AI&#10;                VillagerUtilities.setMarker(villager, plugin, true);&#10;                villager.setAware(true);&#10;            }&#10;        });&#10;        return true;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag.commands;&#10;&#10;import org.bukkit.command.Command;&#10;import org.bukkit.command.CommandExecutor;&#10;import org.bukkit.command.CommandSender;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class UnoptimizeCommand implements CommandExecutor {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;    public UnoptimizeCommand(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;    @Override&#10;    public boolean onCommand(CommandSender commandSender, Command command, String s, String[] strings) {&#10;        if (!command.getName().equalsIgnoreCase(&quot;avlunoptimize&quot;)) return true;&#10;        //  Make sure it's a player&#10;        if (!(commandSender instanceof Player)) return false;&#10;        Player player = (Player) commandSender;&#10;&#10;        //  Check if they have permission&#10;        if(!player.hasPermission(&quot;avl.unoptimize&quot;)) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.no-permission&quot;)));&#10;            return true;&#10;        }&#10;&#10;        //searchable radius based on first argument specified, if null defaults to config&#10;        int radius;&#10;        try{&#10;            radius = (strings != null &amp;&amp; strings.length &gt; 0) ? Integer.parseInt(strings[0]) : plugin.getConfig().getInt(&quot;RadiusDefault&quot;);&#10;        } catch (NumberFormatException e) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-invalid&quot;)));&#10;            return true;&#10;        }&#10;        boolean canSearchRadius = radius &lt;= plugin.getConfig().getInt(&quot;RadiusLimit&quot;);&#10;        if(!canSearchRadius){&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.radius-limit&quot;)).replace(&quot;%avlradiuslimit%&quot;, plugin.getConfig().getString(&quot;RadiusLimit&quot;)));&#10;            return true;&#10;        }&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.searching-radius&quot;)).replace(&quot;%avlradius%&quot;, String.valueOf(radius)));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.bulk-unoptimize-start&quot;)));&#10;&#10;        // Counter for unoptimized villagers&#10;        int unoptimizedCount = 0;&#10;&#10;        // Search for nearby villagers&#10;        for (org.bukkit.entity.Entity entity : player.getNearbyEntities(radius, radius, radius)) {&#10;            if (entity instanceof Villager) {&#10;                Villager villager = (Villager) entity;&#10;                //  Setup new Villagers&#10;                if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;                    VillagerUtilities.setAiCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLevelCooldown(villager, plugin, 0);&#10;                    VillagerUtilities.setLastRestock(villager, plugin);&#10;                    VillagerUtilities.setMarker(villager, plugin, true);&#10;                }&#10;                &#10;                // Only unoptimize if currently optimized&#10;                if (!VillagerUtilities.getMarker(villager, plugin)) {&#10;                    //  Rename villager&#10;                    villager.setCustomName(&quot;&quot;);&#10;                    //  Update the marker and AI&#10;                    VillagerUtilities.setMarker(villager, plugin, true);&#10;                    villager.setAware(true);&#10;                    unoptimizedCount++;&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Send completion message with statistics&#10;        String completeMsg = plugin.getConfig().getString(&quot;messages.bulk-unoptimize-complete&quot;);&#10;        completeMsg = completeMsg.replace(&quot;%avlcount%&quot;, String.valueOf(unoptimizedCount));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(completeMsg));&#10;        &#10;        // Show breeding reminder if villagers were activated&#10;        if (unoptimizedCount &gt; 0) {&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-breeding-reminder&quot;)));&#10;        }&#10;        return true;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/events/EventListener.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/events/EventListener.java" />
              <option name="originalContent" value="package rebelmythik.antiVillagerLag.events;&#10;&#10;import org.bukkit.ChatColor;&#10;import org.bukkit.Material;&#10;import org.bukkit.entity.*;&#10;import org.bukkit.event.Listener;&#10;import org.bukkit.event.EventHandler;&#10;import org.bukkit.event.entity.EntityDamageByEntityEvent;&#10;import org.bukkit.event.inventory.InventoryClickEvent;&#10;import org.bukkit.event.inventory.InventoryCloseEvent;&#10;import org.bukkit.event.inventory.InventoryType;&#10;import org.bukkit.event.inventory.TradeSelectEvent;&#10;import org.bukkit.event.player.PlayerInteractEntityEvent;&#10;import org.bukkit.event.player.PlayerJoinEvent;&#10;import org.bukkit.inventory.ItemStack;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.UpdateChecker;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class EventListener implements Listener {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;&#10;    public EventListener(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;&#10;    @EventHandler&#10;    public void onRightClick(PlayerInteractEntityEvent event) {&#10;        if (event.isCancelled()) return;&#10;        Player player = event.getPlayer();&#10;        //  It's a villager&#10;        if (!event.getRightClicked().getType().equals(EntityType.VILLAGER)) return;&#10;        Villager villager = (Villager) event.getRightClicked();&#10;&#10;        //  Setup new Villagers&#10;        if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;            VillagerUtilities.setAiCooldown(villager, plugin, 0L);&#10;            VillagerUtilities.setLevelCooldown(villager, plugin, 0L);&#10;            VillagerUtilities.setLastRestock(villager, plugin);&#10;            VillagerUtilities.setMarker(villager, plugin, true);&#10;        }&#10;&#10;        //  Get Times&#10;        long currentTime = System.currentTimeMillis() / 1000;&#10;        long vilLevelCooldown = VillagerUtilities.getLevelCooldown(villager, plugin);&#10;        long vilAiCooldown = VillagerUtilities.getAiCooldown(villager, plugin);&#10;        long totalSeconds = vilAiCooldown - currentTime;&#10;        long sec = totalSeconds % 60;&#10;        long min = totalSeconds / 60;&#10;&#10;        //  If the villager is leveling up&#10;        if (vilLevelCooldown &gt; currentTime) {&#10;            String message = plugin.getConfig().getString(&quot;messages.cooldown-levelup-message&quot;);&#10;            long level_sec = vilLevelCooldown - currentTime;&#10;            message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(level_sec));&#10;            event.getPlayer().sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;            villager.shakeHead();&#10;            event.setCancelled(true);&#10;            return;&#10;        }&#10;&#10;        //  Should it be disabled?&#10;        boolean nametag_result = NameTagAI.call(villager, plugin, player);&#10;        boolean block_result = BlockAI.call(villager, plugin, player);&#10;        boolean workblock_result = WorkblockAI.call(villager, plugin, player);&#10;        boolean should_be_disabled = nametag_result || block_result || workblock_result;&#10;&#10;&#10;        //  If villager AI is being toggled&#10;        if (should_be_disabled == VillagerUtilities.getMarker(villager, plugin)) {&#10;            //  If toggling is on cooldown&#10;            if ((vilAiCooldown &gt; currentTime) &amp;&amp; !player.hasPermission(&quot;avl.cooldown.bypass&quot;)) {&#10;                //Tell player it's on cooldown&#10;                String message = plugin.getConfig().getString(&quot;messages.cooldown-ai-message&quot;);&#10;                message = message.replaceAll(&quot;%avlminutes%&quot;, Long.toString(min));&#10;                message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(sec));&#10;                event.getPlayer().sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;                event.setCancelled(true);&#10;            //  If cooldown is over&#10;            } else {&#10;                VillagerUtilities.setMarker(villager, plugin, !should_be_disabled);&#10;                villager.setAware(!should_be_disabled);&#10;                VillagerUtilities.setAiCooldown(villager, plugin, plugin.getConfig().getLong(&quot;ai-toggle-cooldown&quot;));&#10;                //  If nametag shouldn't be consumed, give one back&#10;                if (player.getInventory().getItemInMainHand().getType().equals(Material.NAME_TAG) &amp;&amp; !plugin.getConfig().getBoolean(&quot;toggleableoptions.usenametags&quot;)) {&#10;                    ItemStack nametag = player.getInventory().getItemInMainHand();&#10;                    if (!nametag.getItemMeta().hasDisplayName()) return;&#10;                    player.getInventory().getItemInMainHand().setAmount(player.getInventory().getItemInMainHand().getAmount() + 1);&#10;                }&#10;            }&#10;        }&#10;        //  If the villager AI is not being toggled&#10;        else {&#10;            //  If nametag shouldn't be consumed, give one back&#10;            if (!VillagerUtilities.hasMarker(villager, plugin)) return;&#10;            if (player.getInventory().getItemInMainHand().getType().equals(Material.NAME_TAG) &amp;&amp; !plugin.getConfig().getBoolean(&quot;toggleableoptions.usenametags&quot;)) {&#10;                ItemStack nametag = player.getInventory().getItemInMainHand();&#10;                if (!nametag.getItemMeta().hasDisplayName()) return;&#10;                player.getInventory().getItemInMainHand().setAmount(player.getInventory().getItemInMainHand().getAmount() + 1);&#10;            }&#10;        }&#10;&#10;        //  Restock&#10;        if (!VillagerUtilities.getMarker(villager, plugin)) {&#10;            RestockVillager.call(villager, plugin, player);&#10;        }&#10;    }&#10;&#10;    // Code for forcing players to disable villagers&#10;&#10;    @EventHandler&#10;    public void inventoryMove(InventoryClickEvent event) {&#10;        if (event.isCancelled()) return;&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.preventtrading&quot;)) return;&#10;        if (!(event.getInventory().getHolder() instanceof Villager)) return;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (!VillagerUtilities.getMarker(vil, plugin)) return;&#10;        Player player = (Player) event.getWhoClicked();&#10;        event.setCancelled(true);&#10;        //player.closeInventory();&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.VillagerMustBeDisabled&quot;)));&#10;    }&#10;&#10;    @EventHandler&#10;    public void villagerTradeClick(TradeSelectEvent event) {&#10;        if (event.isCancelled()) return;&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.preventtrading&quot;)) return;&#10;        if (!(event.getInventory().getHolder() instanceof Villager)) return;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (!VillagerUtilities.getMarker(vil, plugin)) return;&#10;        Player player = (Player) event.getWhoClicked();&#10;        event.setCancelled(true);&#10;        player.closeInventory();&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.VillagerMustBeDisabled&quot;)));&#10;    }&#10;&#10;    // Event to handle cancellation of damage to villagers disable by the plugin&#10;    @EventHandler&#10;    public void onCancelVillagerDamage(EntityDamageByEntityEvent event) {&#10;        if (event.isCancelled()) return;&#10;        if (!(event.getEntity() instanceof Villager &amp;&amp; event.getDamager() instanceof Zombie)) return;&#10;&#10;        Villager vil = (Villager) event.getEntity();&#10;&#10;        if (VillagerUtilities.hasMarker(vil, plugin) &amp;&amp; !VillagerUtilities.getMarker(vil, plugin)) {&#10;            event.setCancelled(true);&#10;        }&#10;    }&#10;&#10;    @EventHandler&#10;    public void playerJoin(PlayerJoinEvent event) {&#10;        if (!event.getPlayer().hasPermission(&quot;avl.notify.update&quot;)) return;&#10;        new UpdateChecker(plugin, 102949).getVersion(version -&gt; {&#10;            if (plugin.getDescription().getVersion().equals(version)) {&#10;                event.getPlayer().sendMessage(ChatColor.GREEN + &quot;AntiVillagerLag is up to date!&quot;);&#10;            } else {&#10;                event.getPlayer().sendMessage(ChatColor.GREEN + &quot;There is an update for AntiVillagerLag! https://www.spigotmc.org/resources/antivillagerlag.102949/&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    // Event to handle Villager updating&#10;    @EventHandler&#10;    public void afterTrade(InventoryCloseEvent event) {&#10;&#10;        Player player = (Player) event.getPlayer();&#10;        if(player.hasPermission(&quot;avl.disable&quot;))&#10;            return;&#10;        // check if inventory belongs to a Villager Trade Screen&#10;        if (event.getInventory().getHolder() == null) return;&#10;        if (event.getInventory().getHolder() instanceof WanderingTrader) return;&#10;        if(event.getInventory().getType() != InventoryType.MERCHANT) return;&#10;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        // make sure the villager is disabled&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (VillagerUtilities.getMarker(vil, plugin)) return;&#10;&#10;        // handle leveling&#10;        VillagerLevelManager.call(vil, plugin, player);&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag.events;&#10;&#10;import org.bukkit.ChatColor;&#10;import org.bukkit.Material;&#10;import org.bukkit.entity.*;&#10;import org.bukkit.event.Listener;&#10;import org.bukkit.event.EventHandler;&#10;import org.bukkit.event.entity.EntityDamageByEntityEvent;&#10;import org.bukkit.event.inventory.InventoryClickEvent;&#10;import org.bukkit.event.inventory.InventoryCloseEvent;&#10;import org.bukkit.event.inventory.InventoryType;&#10;import org.bukkit.event.inventory.TradeSelectEvent;&#10;import org.bukkit.event.player.PlayerInteractEntityEvent;&#10;import org.bukkit.event.player.PlayerJoinEvent;&#10;import org.bukkit.inventory.ItemStack;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.UpdateChecker;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class EventListener implements Listener {&#10;&#10;    AntiVillagerLag plugin;&#10;&#10;&#10;    public EventListener(AntiVillagerLag plugin) {&#10;        this.plugin = plugin;&#10;    }&#10;&#10;&#10;    @EventHandler&#10;    public void onRightClick(PlayerInteractEntityEvent event) {&#10;        if (event.isCancelled()) return;&#10;        Player player = event.getPlayer();&#10;        //  It's a villager&#10;        if (!event.getRightClicked().getType().equals(EntityType.VILLAGER)) return;&#10;        Villager villager = (Villager) event.getRightClicked();&#10;&#10;        //  Setup new Villagers&#10;        if (!VillagerUtilities.hasMarker(villager, plugin)) {&#10;            VillagerUtilities.setAiCooldown(villager, plugin, 0L);&#10;            VillagerUtilities.setLevelCooldown(villager, plugin, 0L);&#10;            VillagerUtilities.setLastRestock(villager, plugin);&#10;            VillagerUtilities.setMarker(villager, plugin, true);&#10;        }&#10;&#10;        //  Get Times&#10;        long currentTime = System.currentTimeMillis() / 1000;&#10;        long vilLevelCooldown = VillagerUtilities.getLevelCooldown(villager, plugin);&#10;        long vilAiCooldown = VillagerUtilities.getAiCooldown(villager, plugin);&#10;        long totalSeconds = vilAiCooldown - currentTime;&#10;        long sec = totalSeconds % 60;&#10;        long min = totalSeconds / 60;&#10;&#10;        //  If the villager is leveling up&#10;        if (vilLevelCooldown &gt; currentTime) {&#10;            String message = plugin.getConfig().getString(&quot;messages.cooldown-levelup-message&quot;);&#10;            long level_sec = vilLevelCooldown - currentTime;&#10;            message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(level_sec));&#10;            event.getPlayer().sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;            villager.shakeHead();&#10;            event.setCancelled(true);&#10;            return;&#10;        }&#10;&#10;        //  Should it be disabled?&#10;        boolean nametag_result = NameTagAI.call(villager, plugin, player);&#10;        boolean block_result = BlockAI.call(villager, plugin, player);&#10;        boolean workblock_result = WorkblockAI.call(villager, plugin, player);&#10;        boolean should_be_disabled = nametag_result || block_result || workblock_result;&#10;&#10;&#10;        //  If villager AI is being toggled&#10;        if (should_be_disabled == VillagerUtilities.getMarker(villager, plugin)) {&#10;            //  If toggling is on cooldown&#10;            if ((vilAiCooldown &gt; currentTime) &amp;&amp; !player.hasPermission(&quot;avl.cooldown.bypass&quot;)) {&#10;                //Tell player it's on cooldown&#10;                String message = plugin.getConfig().getString(&quot;messages.cooldown-ai-message&quot;);&#10;                message = message.replaceAll(&quot;%avlminutes%&quot;, Long.toString(min));&#10;                message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(sec));&#10;                event.getPlayer().sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;                event.setCancelled(true);&#10;            //  If cooldown is over&#10;            } else {&#10;                boolean wasOptimized = VillagerUtilities.getMarker(villager, plugin);&#10;                VillagerUtilities.setMarker(villager, plugin, !should_be_disabled);&#10;                villager.setAware(!should_be_disabled);&#10;                VillagerUtilities.setAiCooldown(villager, plugin, plugin.getConfig().getLong(&quot;ai-toggle-cooldown&quot;));&#10;                &#10;                // Enhanced feedback messages&#10;                if (!should_be_disabled) {&#10;                    // Villager was optimized, now being unoptimized (activated)&#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-unoptimized&quot;)));&#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-breeding-reminder&quot;)));&#10;                } else {&#10;                    // Villager was active, now being optimized (disabled)  &#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-optimized&quot;)));&#10;                    player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-performance-tip&quot;)));&#10;                }&#10;                &#10;                //  If nametag shouldn't be consumed, give one back&#10;                if (player.getInventory().getItemInMainHand().getType().equals(Material.NAME_TAG) &amp;&amp; !plugin.getConfig().getBoolean(&quot;toggleableoptions.usenametags&quot;)) {&#10;                    ItemStack nametag = player.getInventory().getItemInMainHand();&#10;                    if (!nametag.getItemMeta().hasDisplayName()) return;&#10;                    player.getInventory().getItemInMainHand().setAmount(player.getInventory().getItemInMainHand().getAmount() + 1);&#10;                }&#10;            }&#10;        }&#10;        //  If the villager AI is not being toggled&#10;        else {&#10;            // Show current status to player&#10;            if (VillagerUtilities.getMarker(villager, plugin)) {&#10;                // Villager is optimized&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-status-optimized&quot;)));&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-info-optimized&quot;)));&#10;            } else {&#10;                // Villager is active  &#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-status-active&quot;)));&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-info-active&quot;)));&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.action-help&quot;)));&#10;            }&#10;            &#10;            //  If nametag shouldn't be consumed, give one back&#10;            if (!VillagerUtilities.hasMarker(villager, plugin)) return;&#10;            if (player.getInventory().getItemInMainHand().getType().equals(Material.NAME_TAG) &amp;&amp; !plugin.getConfig().getBoolean(&quot;toggleableoptions.usenametags&quot;)) {&#10;                ItemStack nametag = player.getInventory().getItemInMainHand();&#10;                if (!nametag.getItemMeta().hasDisplayName()) return;&#10;                player.getInventory().getItemInMainHand().setAmount(player.getInventory().getItemInMainHand().getAmount() + 1);&#10;            }&#10;        }&#10;&#10;        //  Restock&#10;        if (!VillagerUtilities.getMarker(villager, plugin)) {&#10;            RestockVillager.call(villager, plugin, player);&#10;        }&#10;    }&#10;&#10;    // Code for forcing players to disable villagers&#10;&#10;    @EventHandler&#10;    public void inventoryMove(InventoryClickEvent event) {&#10;        if (event.isCancelled()) return;&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.preventtrading&quot;)) return;&#10;        if (!(event.getInventory().getHolder() instanceof Villager)) return;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (!VillagerUtilities.getMarker(vil, plugin)) return;&#10;        Player player = (Player) event.getWhoClicked();&#10;        event.setCancelled(true);&#10;        //player.closeInventory();&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.VillagerMustBeDisabled&quot;)));&#10;    }&#10;&#10;    @EventHandler&#10;    public void villagerTradeClick(TradeSelectEvent event) {&#10;        if (event.isCancelled()) return;&#10;        if (!plugin.getConfig().getBoolean(&quot;toggleableoptions.preventtrading&quot;)) return;&#10;        if (!(event.getInventory().getHolder() instanceof Villager)) return;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (!VillagerUtilities.getMarker(vil, plugin)) return;&#10;        Player player = (Player) event.getWhoClicked();&#10;        event.setCancelled(true);&#10;        player.closeInventory();&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.VillagerMustBeDisabled&quot;)));&#10;    }&#10;&#10;    // Event to handle cancellation of damage to villagers disable by the plugin&#10;    @EventHandler&#10;    public void onCancelVillagerDamage(EntityDamageByEntityEvent event) {&#10;        if (event.isCancelled()) return;&#10;        if (!(event.getEntity() instanceof Villager &amp;&amp; event.getDamager() instanceof Zombie)) return;&#10;&#10;        Villager vil = (Villager) event.getEntity();&#10;&#10;        if (VillagerUtilities.hasMarker(vil, plugin) &amp;&amp; !VillagerUtilities.getMarker(vil, plugin)) {&#10;            event.setCancelled(true);&#10;        }&#10;    }&#10;&#10;    @EventHandler&#10;    public void playerJoin(PlayerJoinEvent event) {&#10;        if (!event.getPlayer().hasPermission(&quot;avl.notify.update&quot;)) return;&#10;        new UpdateChecker(plugin, 102949).getVersion(version -&gt; {&#10;            if (plugin.getDescription().getVersion().equals(version)) {&#10;                event.getPlayer().sendMessage(ChatColor.GREEN + &quot;AntiVillagerLag is up to date!&quot;);&#10;            } else {&#10;                event.getPlayer().sendMessage(ChatColor.GREEN + &quot;There is an update for AntiVillagerLag! https://www.spigotmc.org/resources/antivillagerlag.102949/&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    // Event to handle Villager updating&#10;    @EventHandler&#10;    public void afterTrade(InventoryCloseEvent event) {&#10;&#10;        Player player = (Player) event.getPlayer();&#10;        if(player.hasPermission(&quot;avl.disable&quot;))&#10;            return;&#10;        // check if inventory belongs to a Villager Trade Screen&#10;        if (event.getInventory().getHolder() == null) return;&#10;        if (event.getInventory().getHolder() instanceof WanderingTrader) return;&#10;        if(event.getInventory().getType() != InventoryType.MERCHANT) return;&#10;&#10;        Villager vil = (Villager) event.getInventory().getHolder();&#10;        // make sure the villager is disabled&#10;        if (!VillagerUtilities.hasMarker(vil, plugin)) return;&#10;        if (VillagerUtilities.getMarker(vil, plugin)) return;&#10;&#10;        // handle leveling&#10;        VillagerLevelManager.call(vil, plugin, player);&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/events/RestockVillager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/events/RestockVillager.java" />
              <option name="originalContent" value="package rebelmythik.antiVillagerLag.events;&#10;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class RestockVillager {&#10;&#10;    private static void restockMessage(long timeTillNextRestock, Player player, AntiVillagerLag plugin) {&#10;        long totalsec = timeTillNextRestock / 20;&#10;        long sec = totalsec % 60;&#10;        long min = (totalsec - sec) / 60;&#10;        String message = plugin.getConfig().getString(&quot;messages.next-restock&quot;);&#10;        message = message.replaceAll(&quot;%avlrestockmin%&quot;, Long.toString(min));&#10;        message = message.replaceAll(&quot;%avlrestocksec%&quot;, Long.toString(sec));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;    }&#10;&#10;    public static void call(Villager vil, AntiVillagerLag plugin, Player player) {&#10;&#10;        // Permission to Bypass restock cooldown&#10;        if (player.hasPermission(&quot;avl.restockcooldown.bypass&quot;)) {&#10;            VillagerUtilities.restock(vil);&#10;            VillagerUtilities.setLastRestock(vil, plugin);&#10;            return;&#10;        }&#10;&#10;        // Check if it's time to restock&#10;        long worldTick = vil.getWorld().getFullTime();&#10;        long currentDayTick = vil.getWorld().getTime();&#10;        long beginningOfDayTick = worldTick - currentDayTick;&#10;        long vilTick = VillagerUtilities.getLastRestock(vil, plugin);&#10;&#10;        for (long restockTime : VillagerUtilities.restock_times) {&#10;            long todayRestock = beginningOfDayTick + restockTime;&#10;            if (worldTick &gt;= todayRestock &amp;&amp; vilTick &lt; todayRestock) {&#10;                VillagerUtilities.restock(vil);&#10;                VillagerUtilities.setLastRestock(vil, plugin);&#10;                return;&#10;            }&#10;        }&#10;&#10;        // check if he gets to see cool-down time&#10;        if (player.hasPermission(&quot;avl.message.nextrestock&quot;)) {&#10;            long timeTillNextRestock = Long.MAX_VALUE;&#10;            for (long restockTime : VillagerUtilities.restock_times) {&#10;                long restockTick = beginningOfDayTick + restockTime;&#10;                if (worldTick &lt; restockTick) {&#10;                    timeTillNextRestock = Math.min(timeTillNextRestock, restockTick - worldTick);&#10;                }&#10;            }&#10;&#10;            if (timeTillNextRestock == Long.MAX_VALUE) {&#10;                timeTillNextRestock = (24000 + beginningOfDayTick + VillagerUtilities.restock_times.get(0)) - worldTick;&#10;            }&#10;&#10;            restockMessage(timeTillNextRestock, player, plugin);&#10;        }&#10;    }&#10;&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag.events;&#10;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class RestockVillager {&#10;&#10;    private static void restockMessage(long timeTillNextRestock, Player player, AntiVillagerLag plugin) {&#10;        long totalsec = timeTillNextRestock / 20;&#10;        long sec = totalsec % 60;&#10;        long min = (totalsec - sec) / 60;&#10;        String message = plugin.getConfig().getString(&quot;messages.next-restock&quot;);&#10;        message = message.replaceAll(&quot;%avlrestockmin%&quot;, Long.toString(min));&#10;        message = message.replaceAll(&quot;%avlrestocksec%&quot;, Long.toString(sec));&#10;        player.sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;    }&#10;&#10;    public static void call(Villager vil, AntiVillagerLag plugin, Player player) {&#10;&#10;        // Permission to Bypass restock cooldown&#10;        if (player.hasPermission(&quot;avl.restockcooldown.bypass&quot;)) {&#10;            VillagerUtilities.restock(vil);&#10;            VillagerUtilities.setLastRestock(vil, plugin);&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-restock-success&quot;)));&#10;            return;&#10;        }&#10;&#10;        // Check if it's time to restock&#10;        long worldTick = vil.getWorld().getFullTime();&#10;        long currentDayTick = vil.getWorld().getTime();&#10;        long beginningOfDayTick = worldTick - currentDayTick;&#10;        long vilTick = VillagerUtilities.getLastRestock(vil, plugin);&#10;&#10;        for (long restockTime : VillagerUtilities.restock_times) {&#10;            long todayRestock = beginningOfDayTick + restockTime;&#10;            if (worldTick &gt;= todayRestock &amp;&amp; vilTick &lt; todayRestock) {&#10;                VillagerUtilities.restock(vil);&#10;                VillagerUtilities.setLastRestock(vil, plugin);&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-restock-success&quot;)));&#10;                return;&#10;            }&#10;        }&#10;&#10;        // check if he gets to see cool-down time&#10;        if (player.hasPermission(&quot;avl.message.nextrestock&quot;)) {&#10;            long timeTillNextRestock = Long.MAX_VALUE;&#10;            for (long restockTime : VillagerUtilities.restock_times) {&#10;                long restockTick = beginningOfDayTick + restockTime;&#10;                if (worldTick &lt; restockTick) {&#10;                    timeTillNextRestock = Math.min(timeTillNextRestock, restockTick - worldTick);&#10;                }&#10;            }&#10;&#10;            if (timeTillNextRestock == Long.MAX_VALUE) {&#10;                timeTillNextRestock = (24000 + beginningOfDayTick + VillagerUtilities.restock_times.get(0)) - worldTick;&#10;            }&#10;&#10;            restockMessage(timeTillNextRestock, player, plugin);&#10;        }&#10;    }&#10;&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/events/VillagerLevelManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/rebelmythik/antiVillagerLag/events/VillagerLevelManager.java" />
              <option name="originalContent" value="package rebelmythik.antiVillagerLag.events;&#10;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import org.bukkit.potion.PotionEffect;&#10;import org.bukkit.potion.PotionEffectType;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.CalculateLevel;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class VillagerLevelManager {&#10;&#10;    public static void call(Villager vil, AntiVillagerLag plugin, Player player) {&#10;        int cooldown = 5;&#10;        int vilLevel = vil.getVillagerLevel();&#10;        long newLevel = CalculateLevel.villagerEXP(vil);&#10;        long currentTime = System.currentTimeMillis() / 1000;&#10;&#10;        long vilLevelCooldown = VillagerUtilities.getLevelCooldown(vil, plugin);&#10;        long totalSeconds = vilLevelCooldown - currentTime;&#10;        long sec = totalSeconds % 60;&#10;&#10;        if (vilLevelCooldown &gt; currentTime) {&#10;            String message = plugin.getConfig().getString(&quot;messages.cooldown-levelup-message&quot;);&#10;            message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(sec));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;            return;&#10;        }&#10;&#10;        if (vilLevel &lt; newLevel) {&#10;            VillagerUtilities.setLevelCooldown(vil, plugin, cooldown);&#10;            // make villager immovable while AI is disabled&#10;            vil.addPotionEffect(new PotionEffect(PotionEffectType.SLOW, (int)(cooldown * 20)+20, 120, false, false));&#10;            vil.setAware(true);&#10;        } else return;&#10;&#10;        Bukkit.getScheduler().scheduleSyncDelayedTask(plugin, () -&gt; {&#10;            vil.setAware(false);&#10;        }, 100L);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package rebelmythik.antiVillagerLag.events;&#10;&#10;import org.bukkit.Bukkit;&#10;import org.bukkit.entity.Player;&#10;import org.bukkit.entity.Villager;&#10;import org.bukkit.potion.PotionEffect;&#10;import org.bukkit.potion.PotionEffectType;&#10;import rebelmythik.antiVillagerLag.AntiVillagerLag;&#10;import rebelmythik.antiVillagerLag.utils.CalculateLevel;&#10;import rebelmythik.antiVillagerLag.utils.VillagerUtilities;&#10;&#10;public class VillagerLevelManager {&#10;&#10;    public static void call(Villager vil, AntiVillagerLag plugin, Player player) {&#10;        int cooldown = 5;&#10;        int vilLevel = vil.getVillagerLevel();&#10;        long newLevel = CalculateLevel.villagerEXP(vil);&#10;        long currentTime = System.currentTimeMillis() / 1000;&#10;&#10;        long vilLevelCooldown = VillagerUtilities.getLevelCooldown(vil, plugin);&#10;        long totalSeconds = vilLevelCooldown - currentTime;&#10;        long sec = totalSeconds % 60;&#10;&#10;        if (vilLevelCooldown &gt; currentTime) {&#10;            String message = plugin.getConfig().getString(&quot;messages.cooldown-levelup-message&quot;);&#10;            message = message.replaceAll(&quot;%avlseconds%&quot;, Long.toString(sec));&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(message));&#10;            return;&#10;        }&#10;&#10;        if (vilLevel &lt; newLevel) {&#10;            VillagerUtilities.setLevelCooldown(vil, plugin, cooldown);&#10;            // Notify player that villager is leveling up&#10;            player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-levelup-starting&quot;)));&#10;            // make villager immovable while AI is disabled&#10;            vil.addPotionEffect(new PotionEffect(PotionEffectType.SLOW, (int)(cooldown * 20)+20, 120, false, false));&#10;            vil.setAware(true);&#10;        } else return;&#10;&#10;        Bukkit.getScheduler().scheduleSyncDelayedTask(plugin, () -&gt; {&#10;            vil.setAware(false);&#10;            // Notify player that level up is complete&#10;            if (player.isOnline()) {&#10;                player.sendMessage(VillagerUtilities.colorcodes.cm(plugin.getConfig().getString(&quot;messages.villager-levelup-complete&quot;)));&#10;            }&#10;        }, 100L);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>